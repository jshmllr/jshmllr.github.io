'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventSystem = exports.INTENT = exports.MESSAGE = exports.ERROR = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.error = error;
exports.message = message;
exports.intent = intent;

var _events = require('events');

var _Rx = require('rxjs/Rx');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ERROR = exports.ERROR = 'ERROR';
const MESSAGE = exports.MESSAGE = 'MESSAGE';
const INTENT = exports.INTENT = 'INTENT';

function error(scope, code, data = {}) {
  return {
    type: ERROR,
    scope,
    payload: _extends({
      code
    }, data)
  };
}

function message(scope, code, data = {}) {
  return {
    type: MESSAGE,
    scope,
    payload: _extends({
      code
    }, data)
  };
}

function intent(scope, code, data = {}) {
  return {
    type: INTENT,
    scope,
    payload: _extends({
      code
    }, data)
  };
}

const MESSAGE_KEY = 'message';

class MessageDispatcher {
  constructor(eventSystem, scope) {
    this.eventSystem = eventSystem;
    this.scope = scope;
  }

  dispatch(code, data = {}) {
    return this.eventSystem.emit(message(this.scope, code, data));
  }

  error(code, data = {}) {
    return this.eventSystem.emit(error(this.scope, code, data));
  }

  intent(code, data = {}) {
    return this.eventSystem.emitIntent(intent(this.scope, code, data));
  }
}

class EventSystem {
  constructor() {
    this.emitter = new _events.EventEmitter();
    this.messageStream = _Rx.Observable.fromEvent(this.emitter, MESSAGE_KEY);
  }

  emit(data) {
    this.emitter.emit(MESSAGE_KEY, data);
  }

  emitIntent(intent) {
    return new _bluebird2.default((resolve, reject) => {
      // Basically, create a deferred and emit it
      // while returning the promise it will resolve
      const deferredIntent = Object.assign({
        resolve,
        reject
      }, intent);

      this.emitter.emit('message', deferredIntent);
    });
  }

  dispatcher(scope) {
    return new MessageDispatcher(this, scope);
  }

  attachSubsystem(subsystem) {
    subsystem.connect(this.messageStream);
  }
}
exports.EventSystem = EventSystem;