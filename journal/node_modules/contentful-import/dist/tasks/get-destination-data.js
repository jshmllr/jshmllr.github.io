'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = getDestinationData;

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _logging = require('contentful-batch-libs/dist/logging');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const BATCH_CHAR_LIMIT = 1990;
const BATCH_SIZE_LIMIT = 100;

const METHODS = {
  contentTypes: { name: 'content types', method: 'getContentTypes' },
  locales: { name: 'locales', method: 'getLocales' },
  entries: { name: 'entries', method: 'getEntries' },
  assets: { name: 'assets', method: 'getAssets' }
};

function batchedIdQuery(environment, type, ids) {
  const method = METHODS[type].method;
  const entityTypeName = METHODS[type].name;
  return _bluebird2.default.reduce(getIdBatches(ids), (fullResponse, batch) => {
    return environment[method]({
      'sys.id[in]': batch,
      limit: batch.split(',').length
    }).then(response => {
      fullResponse = [...fullResponse, ...response.items];
      _logging.logEmitter.emit('info', `Fetched ${fullResponse.length} of ${response.total} ${entityTypeName}`);
      return fullResponse;
    });
  }, []);
}

function getIdBatches(ids) {
  const batches = [];
  let currentBatch = '';
  let currentSize = 0;
  while (ids.length > 0) {
    let id = ids.splice(0, 1);
    currentBatch += id;
    currentSize = currentSize + 1;
    if (currentSize === BATCH_SIZE_LIMIT || currentBatch.length > BATCH_CHAR_LIMIT || ids.length === 0) {
      batches.push(currentBatch);
      currentBatch = '';
      currentSize = 0;
    } else {
      currentBatch += ',';
    }
  }
  return batches;
}

/**
 * Gets content from a space which will have content copied to it, based on a
 * collection of existing content.
 *
 * Only the supplied entry/asset IDs will be retrieved. All contentTypes
 * and Locales will be retrieved.
 */

function getDestinationData({
  client,
  spaceId,
  environmentId,
  sourceData,
  contentModelOnly,
  skipLocales,
  skipContentModel
}) {
  return client.getSpace(spaceId).then(space => space.getEnvironment(environmentId)).then(environment => {
    const result = {
      contentTypes: [],
      locales: [],
      entries: [],
      assets: []

      // Make sure all required properties are available and at least an empty array
    };sourceData = _extends({}, result, sourceData);

    if (!skipContentModel) {
      const contentTypeIds = sourceData.contentTypes.map(e => e.sys.id);
      result.contentTypes = batchedIdQuery(environment, 'contentTypes', contentTypeIds);

      if (!skipLocales) {
        const localeIds = sourceData.locales.map(e => e.sys.id);
        result.locales = batchedIdQuery(environment, 'locales', localeIds);
      }
    }

    if (contentModelOnly) {
      return _bluebird2.default.props(result);
    }

    const entryIds = sourceData.entries.map(e => e.sys.id);
    const assetIds = sourceData.assets.map(e => e.sys.id);
    result.entries = batchedIdQuery(environment, 'entries', entryIds);
    result.assets = batchedIdQuery(environment, 'assets', assetIds);
    result.webhooks = [];

    return _bluebird2.default.props(result);
  });
}
module.exports = exports['default'];