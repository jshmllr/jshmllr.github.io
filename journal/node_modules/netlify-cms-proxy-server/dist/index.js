#!/usr/bin/env node
!function(e){var t={};function a(i){if(t[i])return t[i].exports;var s=t[i]={i:i,l:!1,exports:{}};return e[i].call(s.exports,s,s.exports,a),s.l=!0,s.exports}a.m=e,a.c=t,a.d=function(e,t,i){a.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},a.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.t=function(e,t){if(1&t&&(e=a(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(a.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)a.d(i,s,function(t){return e[t]}.bind(null,s));return i},a.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return a.d(t,"a",t),t},a.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},a.p="",a(a.s=7)}([function(e,t){e.exports=require("path")},function(e,t){e.exports=require("fs")},function(e,t,a){"use strict";var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=i(a(3)),r=["info","entriesByFolder","entriesByFiles","getEntry","unpublishedEntries","unpublishedEntry","deleteUnpublishedEntry","persistEntry","updateUnpublishedEntryStatus","publishUnpublishedEntry","getMedia","getMediaFile","persistMedia","deleteFile","getDeployPreview"],n=s.default.string().required(),o=s.default.number().required(),l=s.default.bool().required(),c=n,u=n;t.defaultSchema=({path:e=n}={})=>{const t=s.default.object({branch:n}),a=s.default.object({path:e,content:n,encoding:n.valid("base64")}),i=s.default.when("action",{switch:[{is:"info",then:s.default.allow()},{is:"entriesByFolder",then:t.keys({folder:e,extension:n,depth:o}).required()},{is:"entriesByFiles",then:t.keys({files:s.default.array().items(s.default.object({path:e,label:s.default.string()})).required()})},{is:"getEntry",then:t.keys({path:e}).required()},{is:"unpublishedEntries",then:t.keys({branch:n}).required()},{is:"unpublishedEntry",then:t.keys({collection:c,slug:u}).required()},{is:"deleteUnpublishedEntry",then:t.keys({collection:c,slug:u}).required()},{is:"persistEntry",then:t.keys({entry:s.default.object({slug:n,path:e,raw:n}).required(),assets:s.default.array().items(a).required(),options:s.default.object({collectionName:s.default.string(),commitMessage:n,useWorkflow:l,status:n}).required()}).required()},{is:"updateUnpublishedEntryStatus",then:t.keys({collection:c,slug:u,newStatus:n}).required()},{is:"publishUnpublishedEntry",then:t.keys({collection:c,slug:u}).required()},{is:"getMedia",then:t.keys({mediaFolder:e}).required()},{is:"getMediaFile",then:t.keys({path:e}).required()},{is:"persistMedia",then:t.keys({asset:a.required(),options:s.default.object({commitMessage:n}).required()}).required()},{is:"deleteFile",then:t.keys({path:e,options:s.default.object({commitMessage:n}).required()}).required()},{is:"getDeployPreview",then:t.keys({collection:c,slug:u}).required()}],otherwise:s.default.forbidden()});return s.default.object({action:s.default.valid(...r).required(),params:i})},t.joi=e=>(t,a,i)=>{const{error:s}=e.validate(t.body,{allowUnknown:!0});if(s){const{details:e}=s,t=e.map(e=>e.message).join(",");a.status(422).json({error:t})}else i()}},function(e,t){e.exports=require("@hapi/joi")},function(e,t,a){"use strict";var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=i(a(3)),r=i(a(0));t.pathTraversal=e=>s.default.extend({type:"path",base:s.default.string().required(),messages:{"path.invalid":"{{#label}} must resolve to a path under the configured repository"},validate(t,a){if(!r.default.join(e,t).startsWith(e))return{value:t,errors:a.error("path.invalid")}}}).path()},function(e,t,a){"use strict";var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=i(a(0)),r=a(1),n=async(e,t,a)=>{if(a<=0)return[];try{const i=await r.promises.readdir(e,{withFileTypes:!0}),o=await Promise.all(i.map(i=>{const r=s.default.join(e,i.name);return i.isDirectory()?n(r,t,a-1):[r].filter(e=>e.endsWith(t))}));return[].concat(...o)}catch(e){return[]}};t.listRepoFiles=async(e,t,a,i)=>(await n(s.default.join(e,t),a,i)).map(t=>t.substr(e.length+1)),t.writeFile=async(e,t)=>{await r.promises.mkdir(s.default.dirname(e),{recursive:!0}),await r.promises.writeFile(e,t)},t.deleteFile=async(e,t)=>{await r.promises.unlink(s.default.join(e,t))}},function(e,t,a){"use strict";var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=i(a(15)),r=i(a(0)),n=a(1),o=e=>s.default.createHash("sha256").update(e).digest("hex"),l=e=>e.replace(/\\/g,"/");t.entriesFromFiles=async(e,t)=>Promise.all(t.map(async t=>{try{const a=await n.promises.readFile(r.default.join(e,t.path));return{data:a.toString(),file:{path:l(t.path),label:t.label,id:o(a)}}}catch(e){return{data:null,file:{path:l(t.path),label:t.label,id:null}}}})),t.readMediaFile=async(e,t)=>{const a=await n.promises.readFile(r.default.join(e,t));return{id:o(a),content:a.toString("base64"),encoding:"base64",path:l(t),name:r.default.basename(t)}}},function(e,t,a){"use strict";var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),a(8).config();const s=i(a(9)),r=i(a(10)),n=i(a(11)),o=a(12),l=a(16),c=s.default(),u=process.env.PORT||8081;(async()=>{c.use(r.default("combined")),c.use(n.default()),c.use(s.default.json({limit:"50mb"}));try{const e=process.env.MODE||"fs";if("fs"===e)l.registerMiddleware(c);else{if("git"!==e)throw new Error(`Unknown proxy mode '${e}'`);o.registerMiddleware(c)}}catch(e){console.error(e.message),process.exit(1)}c.listen(u,()=>{console.log(`Netlify CMS Proxy Server listening on port ${u}`)})})()},function(e,t){e.exports=require("dotenv")},function(e,t){e.exports=require("express")},function(e,t){e.exports=require("morgan")},function(e,t){e.exports=require("cors")},function(e,t,a){"use strict";var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=i(a(0)),r=a(1),n=a(13),o=a(2),l=i(a(14)),c=a(4),u=a(5),d=a(6),p=async(e,t,a)=>{await e.add(a),await e.commit(t,a,{"--no-verify":!0,"--no-gpg-sign":!0})},f=async e=>await e.branchLocal().then(e=>e.current),m=async(e,t,a)=>{const i=await f(e);try{return i!==t&&await e.checkout(t),await a()}finally{await e.checkout(i)}},h=e=>`branch.${e}.description`,y=async(e,t,a)=>{const i=n.contentKeyFromBranch(t),{collection:s,slug:r}=n.parseContentKey(i),o=a.find(e=>e.includes(r)),l=a.filter(e=>e!==o),c=await e.raw(["config",h(t)]),u=c&&n.labelToStatus(c.trim());return{slug:r,metaData:{branch:t,collection:s,objects:{entry:{path:o,mediaFiles:l}},status:u}}},w=async(e,t,a,i,s)=>{const r=[];for(let n=0;n<s.length;n++){const o=i[n],l=s[n],c=await y(e,o,l.files.map(e=>e.file)),u=c.metaData.objects.entry.path,[p]=await m(e,o,()=>d.entriesFromFiles(a,[{path:u}])),f=await e.diff([t,o,"--",u]);r.push({...c,...p,isModification:!f.includes("new file")})}return r},g=async(e,t,a,i,r)=>{await u.writeFile(s.default.join(t,a.path),a.raw),await Promise.all(i.map(e=>u.writeFile(s.default.join(t,e.path),Buffer.from(e.content,e.encoding)))),await p(e,r,[a.path,...i.map(e=>e.path)])},b=async(e,t)=>await e.branchLocal().then(({all:e})=>e.includes(t));t.validateRepo=async({repoPath:e})=>{const t=l.default(e).silent(!1);if(!await t.checkIsRepo())throw Error(`${e} is not a valid git repository`)},t.getSchema=({repoPath:e})=>o.defaultSchema({path:c.pathTraversal(e)}),t.localGitMiddleware=({repoPath:e})=>{const t=l.default(e).silent(!1);return async function(a,i){try{const{body:o}=a;if("info"===o.action)return void i.json({repo:s.default.basename(e),publish_modes:["simple","editorial_workflow"],type:"local_git"});const{branch:l}=o.params;if(!await b(t,l)){const e=`Default branch '${l}' doesn't exist`;return void i.status(422).json({error:e})}switch(o.action){case"entriesByFolder":{const a=o.params,{folder:s,extension:r,depth:n}=a,c=await m(t,l,()=>u.listRepoFiles(e,s,r,n).then(t=>d.entriesFromFiles(e,t.map(e=>({path:e})))));i.json(c);break}case"entriesByFiles":{const a=o.params,s=await m(t,l,()=>d.entriesFromFiles(e,a.files));i.json(s);break}case"getEntry":{const a=o.params,[s]=await m(t,l,()=>d.entriesFromFiles(e,[{path:a.path}]));i.json(s);break}case"unpublishedEntries":{const a=await t.branchLocal().then(e=>e.all.filter(e=>e.startsWith(`${n.CMS_BRANCH_PREFIX}/`))),s=await Promise.all(a.map(e=>t.diffSummary([l,e]))),r=await w(t,l,e,a,s);i.json(r);break}case"unpublishedEntry":{const{collection:a,slug:s}=o.params,r=n.generateContentKey(a,s),c=n.branchFromContentKey(r);if(!await b(t,c))return i.status(404).json({message:"Not Found"});{const a=await t.diffSummary([l,c]),[s]=await w(t,l,e,[c],[a]),r=await(async(e,t,a,i)=>await m(e,a,async()=>await Promise.all(i.map(e=>d.readMediaFile(t,e)))))(t,e,c,s.metaData.objects.entry.mediaFiles);i.json({...s,mediaFiles:r})}break}case"deleteUnpublishedEntry":{const{collection:e,slug:a}=o.params,s=n.generateContentKey(e,a),r=n.branchFromContentKey(s);await f(t)===r&&await t.checkoutLocalBranch(l),await t.branch(["-D",r]),i.json({message:`deleted branch: ${r}`});break}case"persistEntry":{const{entry:a,assets:c,options:u}=o.params;if(u.useWorkflow){const i=a.slug,o=u.collectionName,d=n.generateContentKey(o,i),p=n.branchFromContentKey(d);await m(t,l,async()=>{await b(t,p)?await t.checkout(p):await t.checkoutLocalBranch(p),await(async(e,t)=>{const a=await e.raw(["config","commit.gpgsign"]);try{"true"===a&&await e.addConfig("commit.gpgsign","false"),await e.rebase([t,"--no-verify"])}finally{"true"===a&&await e.addConfig("commit.gpgsign",a)}})(t,l);const i=await t.diffSummary([l,p]),o=await y(t,l,i.files.map(e=>e.file)),d=o.metaData.objects.entry.mediaFiles.filter(e=>!c.map(e=>e.path).includes(e));if(await Promise.all(d.map(t=>r.promises.unlink(s.default.join(e,t)))),await g(t,e,a,c,u.commitMessage),!o.metaData.status){const e=n.statusToLabel(u.status);await t.addConfig(h(p),e)}o.metaData.objects.entry.path||(o.metaData.objects.entry.path=a.path)})}else m(t,l,async()=>{await g(t,e,a,c,u.commitMessage)});i.json({message:"entry persisted"});break}case"updateUnpublishedEntryStatus":{const{collection:e,slug:a,newStatus:s}=o.params,r=n.generateContentKey(e,a),c=n.branchFromContentKey(r),u=n.statusToLabel(s);await t.addConfig(h(c),u),i.json({message:`${l} description was updated to ${u}`});break}case"publishUnpublishedEntry":{const{collection:e,slug:a}=o.params,s=n.generateContentKey(e,a),r=n.branchFromContentKey(s);await(async(e,t,a)=>{const i=await e.raw(["config","commit.gpgsign"]);try{"true"===i&&await e.addConfig("commit.gpgsign","false"),await e.mergeFromTo(t,a)}finally{"true"===i&&await e.addConfig("commit.gpgsign",i)}})(t,r,l),await t.deleteLocalBranch(r),i.json({message:`branch ${r} merged to ${l}`});break}case"getMedia":{const{mediaFolder:a}=o.params,s=await m(t,l,async()=>{const t=await u.listRepoFiles(e,a,"",1);return await Promise.all(t.map(t=>d.readMediaFile(e,t)))});i.json(s);break}case"getMediaFile":{const{path:a}=o.params,s=await m(t,l,()=>d.readMediaFile(e,a));i.json(s);break}case"persistMedia":{const{asset:a,options:{commitMessage:r}}=o.params,n=await m(t,l,async()=>(await u.writeFile(s.default.join(e,a.path),Buffer.from(a.content,a.encoding)),await p(t,r,[a.path]),d.readMediaFile(e,a.path)));i.json(n);break}case"deleteFile":{const{path:a,options:{commitMessage:n}}=o.params;await m(t,l,async()=>{await r.promises.unlink(s.default.join(e,a)),await p(t,n,[a])}),i.json({message:`deleted file ${a}`});break}case"getDeployPreview":i.json(null);break;default:{const e=`Unknown action ${o.action}`;i.status(422).json({error:e});break}}}catch(e){console.error(`Error handling ${JSON.stringify(a.body)}: ${e.message}`),i.status(500).json({error:"Unknown error"})}}},t.registerMiddleware=async e=>{const a=s.default.resolve(process.env.GIT_REPO_DIRECTORY||process.cwd());await t.validateRepo({repoPath:a}),e.post("/api/v1",o.joi(t.getSchema({repoPath:a}))),e.post("/api/v1",t.localGitMiddleware({repoPath:a})),console.log(`Netlify CMS Git Proxy Server configured with ${a}`)}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CMS_BRANCH_PREFIX="cms",t.DEFAULT_PR_BODY="Automatically generated by Netlify CMS",t.MERGE_COMMIT_MESSAGE="Automatically generated. Merged on Netlify CMS.";t.isCMSLabel=e=>e.startsWith("netlify-cms/"),t.labelToStatus=e=>e.substr("netlify-cms/".length),t.statusToLabel=e=>`netlify-cms/${e}`,t.generateContentKey=(e,t)=>`${e}/${t}`,t.parseContentKey=e=>{const t=e.indexOf("/");return{collection:e.substr(0,t),slug:e.substr(t+1)}},t.contentKeyFromBranch=e=>e.substring(`${t.CMS_BRANCH_PREFIX}/`.length),t.branchFromContentKey=e=>`${t.CMS_BRANCH_PREFIX}/${e}`,t.readFile=async(e,t,a,i)=>{const s=e?i?`gh.${e}`:`gh.${e}.blob`:null,r=s?await a.getItem(s):null;if(r)return r;const n=await t();return s&&a.setItem(s,n),n};const i=["deploy"];t.isPreviewContext=(e,t)=>t?e===t:i.some(t=>e.includes(t)),function(e){e.Other="other",e.Success="success"}(t.PreviewState||(t.PreviewState={})),t.getPreviewStatus=(e,a)=>e.find(({context:e})=>t.isPreviewContext(e,a))},function(e,t){e.exports=require("simple-git/promise")},function(e,t){e.exports=require("crypto")},function(e,t,a){"use strict";var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const s=i(a(0)),r=a(2),n=a(4),o=a(5),l=a(6);t.localFsMiddleware=({repoPath:e})=>async function(t,a){try{const{body:i}=t;switch(i.action){case"info":a.json({repo:s.default.basename(e),publish_modes:["simple"],type:"local_fs"});break;case"entriesByFolder":{const t=i.params,{folder:s,extension:r,depth:n}=t,c=await o.listRepoFiles(e,s,r,n).then(t=>l.entriesFromFiles(e,t.map(e=>({path:e}))));a.json(c);break}case"entriesByFiles":{const t=i.params,s=await l.entriesFromFiles(e,t.files);a.json(s);break}case"getEntry":{const t=i.params,[s]=await l.entriesFromFiles(e,[{path:t.path}]);a.json(s);break}case"persistEntry":{const{entry:t,assets:r}=i.params;await o.writeFile(s.default.join(e,t.path),t.raw),await Promise.all(r.map(t=>o.writeFile(s.default.join(e,t.path),Buffer.from(t.content,t.encoding)))),a.json({message:"entry persisted"});break}case"getMedia":{const{mediaFolder:t}=i.params,s=await o.listRepoFiles(e,t,"",1),r=await Promise.all(s.map(t=>l.readMediaFile(e,t)));a.json(r);break}case"getMediaFile":{const{path:t}=i.params,s=await l.readMediaFile(e,t);a.json(s);break}case"persistMedia":{const{asset:t}=i.params;await o.writeFile(s.default.join(e,t.path),Buffer.from(t.content,t.encoding));const r=await l.readMediaFile(e,t.path);a.json(r);break}case"deleteFile":{const{path:t}=i.params;await o.deleteFile(e,t),a.json({message:`deleted file ${t}`});break}case"getDeployPreview":a.json(null);break;default:{const e=`Unknown action ${i.action}`;a.status(422).json({error:e});break}}}catch(e){console.error(`Error handling ${JSON.stringify(t.body)}: ${e.message}`),a.status(500).json({error:"Unknown error"})}},t.getSchema=({repoPath:e})=>r.defaultSchema({path:n.pathTraversal(e)}),t.registerMiddleware=async e=>{const a=s.default.resolve(process.env.GIT_REPO_DIRECTORY||process.cwd());e.post("/api/v1",r.joi(t.getSchema({repoPath:a}))),e.post("/api/v1",t.localFsMiddleware({repoPath:a})),console.log(`Netlify CMS File System Proxy Server configured with ${a}`)}}]);
//# sourceMappingURL=index.js.map