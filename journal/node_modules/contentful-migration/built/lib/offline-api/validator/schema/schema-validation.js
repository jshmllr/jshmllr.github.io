"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Joi = __importStar(require("joi"));
const _ = __importStar(require("lodash"));
const hoek_1 = require("hoek");
const kind_of_1 = __importDefault(require("kind-of"));
const errors_1 = __importDefault(require("../errors"));
const content_type_schema_1 = require("./content-type-schema");
const fields_schema_1 = __importDefault(require("./fields-schema"));
const validateContentType = function (contentType) {
    const contentTypeId = contentType.id;
    const { error } = Joi.validate(_.omit(contentType.toAPI(), ['sys']), content_type_schema_1.contentTypeSchema, {
        abortEarly: false
    });
    if (!error) {
        return [];
    }
    return error.details.map(({ path, type }) => {
        if (type === 'any.required') {
            return {
                type: 'InvalidPayload',
                message: errors_1.default.contentType.REQUIRED_PROPERTY(path)
            };
        }
        if (type === 'array.max' && path === 'fields') {
            return {
                type: 'InvalidPayload',
                message: errors_1.default.contentType.TOO_MANY_FIELDS(contentTypeId, content_type_schema_1.MAX_FIELDS)
            };
        }
    });
};
exports.validateContentType = validateContentType;
const unknownCombinationError = function ({ path, keys }) {
    const type = 'object.unknownCombination';
    const message = `"${keys.join()}" is not allowed`;
    const context = { keys };
    return { message, path, type, context };
};
// Receives ValidationError[] with this structure:
// [{
//   message: '"foo" is not allowed',
//   path: '0.validations.2.foo',
//   type: 'object.allowUnknown',
//   context: { child: 'foo', key: 'foo' }
// }]
const combineErrors = function (fieldValidationsErrors) {
    const byItemPath = _.groupBy(fieldValidationsErrors, ({ path }) => {
        return path.split('.').slice(0, -1).join('.');
    });
    const pathErrorTuples = _.entries(byItemPath);
    const uniqPropErrorsByPath = _.map(pathErrorTuples, ([path, itemErrors]) => {
        const uniqErrors = _.uniqBy(itemErrors, 'context.key');
        return [path, uniqErrors];
    });
    return uniqPropErrorsByPath.map(([path, errors]) => {
        const keys = errors.map((error) => hoek_1.reach(error, 'context.key'));
        // Invalid property
        if (keys.length === 1) {
            const [errorSample] = errors;
            return errorSample;
        }
        // Invalid combined properties
        return unknownCombinationError({ path, keys });
    });
};
// Joi might return an `object.allowUnknown` error for each
// non-matched field validation in `Joi.alternatives.try()`.
// They are noise, execept when all error types are the same.
const cleanNoiseFromJoiErrors = function (error) {
    const [normalErrors, fieldValidationsErrors] = _.partition(error.details, (detail) => {
        const [, fieldProp] = detail.path.split('.');
        return fieldProp !== 'validations';
    });
    if (!fieldValidationsErrors.length) {
        return normalErrors;
    }
    const isUnknownValidationsProp = fieldValidationsErrors.every(({ type }) => type === 'object.allowUnknown');
    if (isUnknownValidationsProp) {
        const combinedErrors = combineErrors(fieldValidationsErrors);
        return [...normalErrors, ...combinedErrors];
    }
    const remainingFieldValidationsErrors = fieldValidationsErrors.filter(({ type }) => type !== 'object.allowUnknown');
    return [...normalErrors, ...remainingFieldValidationsErrors];
};
const validateFields = function (contentType) {
    const fields = contentType.fields.toRaw();
    const { error } = Joi.validate(fields, fields_schema_1.default, {
        abortEarly: false
    });
    if (!error) {
        return [];
    }
    return cleanNoiseFromJoiErrors(error).map((details) => {
        const { path, type, context } = details;
        // `path` looks like `0.field`
        // look up the field
        const [index, ...fieldNames] = path.split('.');
        const prop = fieldNames.join('.');
        const field = fields[index];
        if (type === 'any.required') {
            if (context.isRequiredDependency) {
                const dependentProp = context.dependsOn.key;
                const dependentValue = context.dependsOn.value;
                return {
                    type: 'InvalidPayload',
                    message: errors_1.default.field.REQUIRED_DEPENDENT_PROPERTY(prop, field.id, dependentProp, dependentValue)
                };
            }
            return {
                type: 'InvalidPayload',
                message: errors_1.default.field.REQUIRED_PROPERTY(prop, field.id)
            };
        }
        if (type === 'any.unknown') {
            if (context.isForbiddenDependency) {
                const dependentProp = context.dependsOn.key;
                const dependentValue = context.dependsOn.value;
                return {
                    type: 'InvalidPayload',
                    message: errors_1.default.field.FORBIDDEN_DEPENDENT_PROPERTY(prop, field.id, dependentProp, dependentValue)
                };
            }
            return {
                type: 'InvalidPayload',
                message: errors_1.default.field.FORBIDDEN_PROPERTY(prop, field.id)
            };
        }
        if (type === 'any.allowOnly') {
            return {
                type: 'InvalidPayload',
                message: errors_1.default.field.PROPERTY_MUST_BE_ONE_OF(prop, field.id, context.valids)
            };
        }
        if (type === 'any.invalid' && path.includes('newId')) {
            return {
                type: 'InvalidPayload',
                message: errors_1.default.field.ID_MUST_BE_DIFFERENT(field.id)
            };
        }
        const isIdSchemaError = (type) => {
            return ['string.max', 'any.empty', 'string.regex.base'].includes(type);
        };
        if (path.includes('newId') && isIdSchemaError(type)) {
            return {
                type: 'InvalidPayload',
                message: errors_1.default.field.ID_MUST_MATCH_SCHEMA(field.id, field.newId)
            };
        }
        // Field `validations` errors
        if (prop.startsWith('validations')) {
            if (type === 'array.unique') {
                return {
                    type: 'InvalidPayload',
                    message: errors_1.default.field.validations.DUPLICATED_VALIDATION(context.dupeValue)
                };
            }
            if (type === 'object.allowUnknown') {
                return {
                    type: 'InvalidPayload',
                    message: errors_1.default.field.validations.INVALID_VALIDATION_PROPERTY(context.key)
                };
            }
            if (type === 'object.unknownCombination') {
                return {
                    type: 'InvalidPayload',
                    message: errors_1.default.field.validations.INVALID_VALIDATION_PROPERTY_COMBINATION(context.keys)
                };
            }
            if (type.endsWith('.base')) {
                const [expectedType] = type.split('.base');
                const actualType = kind_of_1.default(hoek_1.reach(field, prop));
                return {
                    type: 'InvalidPayload',
                    message: errors_1.default.field.validations.INVALID_VALIDATION_PARAMETER(context.key, expectedType, actualType)
                };
            }
        }
    });
};
exports.validateFields = validateFields;
//# sourceMappingURL=schema-validation.js.map