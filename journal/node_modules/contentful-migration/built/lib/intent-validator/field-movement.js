"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Joi = __importStar(require("joi"));
const didyoumean2_1 = __importDefault(require("didyoumean2"));
const kind_of_1 = __importDefault(require("kind-of"));
const validationErrors = {
    INVALID_MOVEMENT_TYPE: (typeName) => {
        return `"${typeName}" is not a valid type for field movement. Expected "string".`;
    },
    INVALID_MOVEMENT_WITH_SELF: (fieldId) => {
        return `You cannot move the field "${fieldId}" relative to itself.`;
    },
    INVALID_MOVEMENT_NAME: (movement) => {
        return `"${movement}" is not a valid field movement.`;
    },
    INVALID_MOVEMENT_NAME_WITH_SUGGESTION: (movement, suggestion) => {
        return `${validationErrors.INVALID_MOVEMENT_NAME(movement)} Did you mean "${suggestion}"?`;
    }
};
/*
  While this class very closely follows the SchemaValidator,
  it does have slightly different logic that I did not want to abstract
  into the SchemaValidator too. So for now there is a bit of duplication
*/
class FieldMovementStepValidator {
    appliesTo(step) {
        return step.isFieldMove();
    }
    get validationErrors() {
        return validationErrors;
    }
    get schema() {
        return {
            toTheTop: Joi.any(),
            toTheBottom: Joi.any(),
            afterField: Joi.string().required(),
            beforeField: Joi.string().required()
        };
    }
    validate(intent) {
        const validationErrors = this.validationErrors;
        const fieldMovementValidations = this.schema;
        const validMoves = Object.keys(fieldMovementValidations);
        const movement = intent.getDirection();
        if (validMoves.includes(movement)) {
            const pivot = intent.getPivotId();
            const schema = fieldMovementValidations[movement];
            const { error } = Joi.validate(pivot, schema);
            const pivotType = kind_of_1.default(pivot);
            const sourceFieldId = intent.getFieldId();
            if (error) {
                return [
                    {
                        type: 'InvalidType',
                        message: validationErrors.INVALID_MOVEMENT_TYPE(pivotType),
                        details: { intent }
                    }
                ];
            }
            if (sourceFieldId === pivot) {
                return [
                    {
                        type: 'InvalidMovement',
                        message: validationErrors.INVALID_MOVEMENT_WITH_SELF(sourceFieldId),
                        details: { intent }
                    }
                ];
            }
            return [];
        }
        const suggestion = didyoumean2_1.default(movement, validMoves);
        let message = validationErrors.INVALID_MOVEMENT_NAME(movement);
        if (suggestion) {
            message = validationErrors.INVALID_MOVEMENT_NAME_WITH_SUGGESTION(movement, suggestion);
        }
        return [
            {
                type: 'InvalidMovement',
                message,
                details: { intent }
            }
        ];
    }
}
exports.default = FieldMovementStepValidator;
//# sourceMappingURL=field-movement.js.map