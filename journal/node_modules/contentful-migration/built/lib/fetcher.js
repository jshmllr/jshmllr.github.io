"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const bluebird_1 = __importDefault(require("bluebird"));
class Fetcher {
    constructor(makeRequest) {
        this.makeRequest = makeRequest;
    }
    async getEntriesInIntents(intentList) {
        const loadAllEntries = intentList.getIntents().some((intent) => intent.requiresAllEntries());
        const ids = _.uniq(intentList.getIntents()
            .filter((intent) => intent.isContentTransform() || intent.isEntryDerive() || intent.isEntryTransformToType())
            .map((intent) => intent.getContentTypeId()));
        if (!loadAllEntries && ids.length === 0) {
            return [];
        }
        const filter = {
            'sys.archivedAt[exists]': 'false'
        };
        // If we want to load all entries, we do not need to add the filter specification
        // that loads just the entries for related content types
        // If we do, then we specify the list of CTs that we want entries for
        if (!loadAllEntries) {
            filter['sys.contentType.sys.id[in]'] = ids.join(',');
        }
        const entries = await this.fetchAllPaginatedItems('/entries', filter);
        return entries;
    }
    async getContentTypesInChunks(intentList) {
        // Excluding editor interface intents here since, API-wise, editor interfaces don't require
        // to know the full details about the associated content type.
        const ids = _.uniq(intentList.getIntents()
            .filter((intent) => (!intent.isEditorInterfaceIntent()))
            .reduce((ids, intent) => {
            const intentIds = intent.getRelatedContentTypeIds();
            return ids.concat(intentIds);
        }, []));
        if (ids.length === 0) {
            return [];
        }
        const filter = {
            'sys.id[in]': ids.join(',')
        };
        const contentTypes = await this.fetchAllPaginatedItems('/content_types', filter);
        return contentTypes;
    }
    async getEditorInterfacesInIntents(intentList) {
        const contentTypeIds = _.uniq(intentList.getIntents()
            .filter((intent) => intent.isFieldRename() ||
            intent.isEditorInterfaceIntent())
            .reduce((ids, intent) => {
            const intentIds = intent.getRelatedContentTypeIds();
            return ids.concat(intentIds);
        }, []));
        let editorInterfaces = new Map();
        if (contentTypeIds.length === 0) {
            return editorInterfaces;
        }
        for (let id of contentTypeIds) {
            await this.fetchEditorInterface(id, editorInterfaces);
        }
        return editorInterfaces;
    }
    async getLocalesForSpace() {
        const locales = await this.fetchAllPaginatedItems('/locales');
        return locales.map((i) => i.code);
    }
    async checkContentTypesForDeletedCts(intentList, contentTypes) {
        const deletedCtIds = new Set(intentList.getIntents()
            .filter((intent) => intent.isContentTypeDelete())
            .map((intent) => intent.getContentTypeId()));
        if (deletedCtIds.size === 0) {
            return contentTypes;
        }
        const self = this;
        return bluebird_1.default.map(contentTypes, async function (ct) {
            if (deletedCtIds.has(ct.id)) {
                const response = await self.makeRequest({
                    method: 'GET',
                    url: `/entries?sys.contentType.sys.id=${ct.id}`
                });
                if (response.items.length > 0) {
                    ct.hasEntries = true;
                }
            }
            return ct;
        });
    }
    async fetchEditorInterface(id, editorInterfaces) {
        try {
            const response = await this.makeRequest({
                method: 'GET',
                url: `/content_types/${id}/editor_interface`
            });
            editorInterfaces.set(id, response);
        }
        catch (error) {
            if (error.name === 'NotFound') { // TODO: expose status codes and use that instead.
                // Initialize a default structure for newly created content types.
                editorInterfaces.set(id, {
                    sys: {
                        version: 0
                    },
                    controls: []
                });
            }
            else {
                throw error;
            }
        }
    }
    async fetchAllPaginatedItems(url, params = {}) {
        let entities = [];
        let skip = 0;
        while (true) {
            const paramsWithSkip = Object.assign({}, params, { skip: skip.toString(10) });
            let urlParams = '';
            for (const [key, value] of Object.entries(paramsWithSkip)) {
                urlParams = `${urlParams}&${key}=${value}`;
            }
            const response = await this.makeRequest({
                method: 'GET',
                url: `${url}?${urlParams.substr(1)}`
            });
            entities = entities.concat(response.items);
            skip += response.items.length;
            if (skip >= response.total) {
                break;
            }
        }
        return entities;
    }
}
exports.default = Fetcher;
//# sourceMappingURL=fetcher.js.map