"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.API_NAME = void 0;

var _filter2 = _interopRequireDefault(require("lodash/fp/filter"));

var _map2 = _interopRequireDefault(require("lodash/fp/map"));

var _trim2 = _interopRequireDefault(require("lodash/trim"));

var _trimStart2 = _interopRequireDefault(require("lodash/trimStart"));

var _differenceBy2 = _interopRequireDefault(require("lodash/differenceBy"));

var _result2 = _interopRequireDefault(require("lodash/result"));

var _partial2 = _interopRequireDefault(require("lodash/partial"));

var _last2 = _interopRequireDefault(require("lodash/last"));

var _initial2 = _interopRequireDefault(require("lodash/initial"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _flow2 = _interopRequireDefault(require("lodash/flow"));

var _jsBase = require("js-base64");

var _semaphore = _interopRequireDefault(require("semaphore"));

var _netlifyCmsLibUtil = require("netlify-cms-lib-util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const CURRENT_METADATA_VERSION = '1';
const API_NAME = 'GitHub';
exports.API_NAME = API_NAME;
var GitHubCommitStatusState;

(function (GitHubCommitStatusState) {
  GitHubCommitStatusState["Error"] = "error";
  GitHubCommitStatusState["Failure"] = "failure";
  GitHubCommitStatusState["Pending"] = "pending";
  GitHubCommitStatusState["Success"] = "success";
})(GitHubCommitStatusState || (GitHubCommitStatusState = {}));

const replace404WithEmptyArray = err => {
  if (err && err.status === 404) {
    console.log('This 404 was expected and handled appropriately.');
    return [];
  } else {
    return Promise.reject(err);
  }
};

class API {
  constructor(config) {
    _defineProperty(this, "apiRoot", void 0);

    _defineProperty(this, "token", void 0);

    _defineProperty(this, "branch", void 0);

    _defineProperty(this, "useOpenAuthoring", void 0);

    _defineProperty(this, "repo", void 0);

    _defineProperty(this, "originRepo", void 0);

    _defineProperty(this, "repoURL", void 0);

    _defineProperty(this, "originRepoURL", void 0);

    _defineProperty(this, "mergeMethod", void 0);

    _defineProperty(this, "initialWorkflowStatus", void 0);

    _defineProperty(this, "_userPromise", void 0);

    _defineProperty(this, "_metadataSemaphore", void 0);

    _defineProperty(this, "commitAuthor", void 0);

    _defineProperty(this, "getPRsForBranchName", branchName => {
      // Get PRs with a `head` of `branchName`. Note that this is a
      // substring match, so we need to check that the `head.ref` of
      // at least one of the returned objects matches `branchName`.
      return this.requestAllPages("".concat(this.repoURL, "/pulls"), {
        params: {
          head: branchName,
          state: 'open',
          base: this.branch
        }
      });
    });

    _defineProperty(this, "getUpdatedOpenAuthoringMetadata", async (contentKey, {
      metadata: metadataArg
    } = {}) => {
      const metadata = metadataArg || (await this.retrieveMetadata(contentKey)) || {};
      const {
        pr: prMetadata,
        status
      } = metadata; // Set the status to draft if no corresponding PR is recorded

      if (!prMetadata && status !== 'draft') {
        const newMetadata = _objectSpread({}, metadata, {
          status: 'draft'
        });

        this.storeMetadata(contentKey, newMetadata);
        return newMetadata;
      } // If no status is recorded, but there is a PR, check if the PR is
      // closed or not and update the status accordingly.


      if (prMetadata) {
        const {
          number: prNumber
        } = prMetadata;
        const originPRInfo = await this.getPullRequest(prNumber);
        const {
          state: currentState,
          merged_at: mergedAt
        } = originPRInfo;

        if (currentState === 'closed' && mergedAt) {
          // The PR has been merged; delete the unpublished entry
          const {
            collection
          } = metadata;
          const slug = this.slugFromContentKey(contentKey, collection);
          this.deleteUnpublishedEntry(collection, slug);
          return;
        } else if (currentState === 'closed' && !mergedAt) {
          if (status !== 'draft') {
            const newMetadata = _objectSpread({}, metadata, {
              status: 'draft'
            });

            await this.storeMetadata(contentKey, newMetadata);
            return newMetadata;
          }
        } else {
          if (status !== 'pending_review') {
            // PR is open and has not been merged
            const newMetadata = _objectSpread({}, metadata, {
              status: 'pending_review'
            });

            await this.storeMetadata(contentKey, newMetadata);
            return newMetadata;
          }
        }
      }

      return metadata;
    });

    this.apiRoot = config.apiRoot || 'https://api.github.com';
    this.token = config.token || '';
    this.branch = config.branch || 'master';
    this.useOpenAuthoring = config.useOpenAuthoring;
    this.repo = config.repo || '';
    this.originRepo = config.originRepo || this.repo;
    this.repoURL = "/repos/".concat(this.repo); // when not in 'useOpenAuthoring' mode originRepoURL === repoURL

    this.originRepoURL = "/repos/".concat(this.originRepo);
    this.mergeMethod = config.squashMerges ? 'squash' : 'merge';
    this.initialWorkflowStatus = config.initialWorkflowStatus;
  }

  user() {
    if (!this._userPromise) {
      this._userPromise = this.request('/user');
    }

    return this._userPromise;
  }

  hasWriteAccess() {
    return this.request(this.repoURL).then(repo => repo.permissions.push).catch(error => {
      console.error('Problem fetching repo data from GitHub');
      throw error;
    });
  }

  reset() {// no op
  }

  requestHeaders(headers = {}) {
    const baseHeader = _objectSpread({
      'Content-Type': 'application/json; charset=utf-8'
    }, headers);

    if (this.token) {
      baseHeader.Authorization = "token ".concat(this.token);
      return Promise.resolve(baseHeader);
    }

    return Promise.resolve(baseHeader);
  }

  parseJsonResponse(response) {
    return response.json().then(json => {
      if (!response.ok) {
        return Promise.reject(json);
      }

      return json;
    });
  }

  urlFor(path, options) {
    const cacheBuster = new Date().getTime();
    const params = ["ts=".concat(cacheBuster)];

    if (options.params) {
      for (const key in options.params) {
        params.push("".concat(key, "=").concat(encodeURIComponent(options.params[key])));
      }
    }

    if (params.length) {
      path += "?".concat(params.join('&'));
    }

    return this.apiRoot + path;
  }

  parseResponse(response) {
    const contentType = response.headers.get('Content-Type');

    if (contentType && contentType.match(/json/)) {
      return this.parseJsonResponse(response);
    }

    const textPromise = response.text().then(text => {
      if (!response.ok) {
        return Promise.reject(text);
      }

      return text;
    });
    return textPromise;
  }

  handleRequestError(error, responseStatus) {
    throw new _netlifyCmsLibUtil.APIError(error.message, responseStatus, API_NAME);
  }

  async request(path, options = {}, // eslint-disable-next-line @typescript-eslint/no-explicit-any
  parser = response => this.parseResponse(response)) {
    const headers = await this.requestHeaders(options.headers || {});
    const url = this.urlFor(path, options);
    let responseStatus;
    return fetch(url, _objectSpread({}, options, {
      headers
    })).then(response => {
      responseStatus = response.status;
      return parser(response);
    }).catch(error => this.handleRequestError(error, responseStatus));
  }

  nextUrlProcessor() {
    return url => url;
  }

  async requestAllPages(url, options = {}) {
    const headers = await this.requestHeaders(options.headers || {});
    const processedURL = this.urlFor(url, options);
    const allResponses = await (0, _netlifyCmsLibUtil.getAllResponses)(processedURL, _objectSpread({}, options, {
      headers
    }), 'next', this.nextUrlProcessor());
    const pages = await Promise.all(allResponses.map(res => this.parseResponse(res)));
    return [].concat(...pages);
  }

  generateContentKey(collectionName, slug) {
    if (!this.useOpenAuthoring) {
      return (0, _netlifyCmsLibUtil.generateContentKey)(collectionName, slug);
    }

    return "".concat(this.repo, "/").concat(collectionName, "/").concat(slug);
  }

  slugFromContentKey(contentKey, collectionName) {
    if (!this.useOpenAuthoring) {
      return contentKey.substring(collectionName.length + 1);
    }

    return contentKey.substring(this.repo.length + collectionName.length + 2);
  }

  generateBranchName(contentKey) {
    return "".concat(_netlifyCmsLibUtil.CMS_BRANCH_PREFIX, "/").concat(contentKey);
  }

  branchNameFromRef(ref) {
    return ref.substring('refs/heads/'.length);
  }

  contentKeyFromRef(ref) {
    return ref.substring("refs/heads/".concat(_netlifyCmsLibUtil.CMS_BRANCH_PREFIX, "/").length);
  }

  checkMetadataRef() {
    return this.request("".concat(this.repoURL, "/git/refs/meta/_netlify_cms"), {
      cache: 'no-store'
    }).then(response => response.object).catch(() => {
      // Meta ref doesn't exist
      const readme = {
        raw: '# Netlify CMS\n\nThis tree is used by the Netlify CMS to store metadata information for specific files and branches.'
      };
      return this.uploadBlob(readme).then(item => this.request("".concat(this.repoURL, "/git/trees"), {
        method: 'POST',
        body: JSON.stringify({
          tree: [{
            path: 'README.md',
            mode: '100644',
            type: 'blob',
            sha: item.sha
          }]
        })
      })).then(tree => this.commit('First Commit', tree)).then(response => this.createRef('meta', '_netlify_cms', response.sha)).then(response => response.object);
    });
  }

  async storeMetadata(key, data) {
    // semaphore ensures metadata updates are always ordered, even if
    // calls to storeMetadata are not. concurrent metadata updates
    // will result in the metadata branch being unable to update.
    if (!this._metadataSemaphore) {
      this._metadataSemaphore = (0, _semaphore.default)(1);
    }

    return new Promise((resolve, reject) => {
      var _this$_metadataSemaph;

      return (_this$_metadataSemaph = this._metadataSemaphore) === null || _this$_metadataSemaph === void 0 ? void 0 : _this$_metadataSemaph.take(async () => {
        try {
          var _this$_metadataSemaph2;

          const branchData = await this.checkMetadataRef();
          const file = {
            path: "".concat(key, ".json"),
            raw: JSON.stringify(data)
          };
          await this.uploadBlob(file);
          const changeTree = await this.updateTree(branchData.sha, [file]);
          const {
            sha
          } = await this.commit("Updating \u201C".concat(key, "\u201D metadata"), changeTree);
          await this.patchRef('meta', '_netlify_cms', sha);

          _netlifyCmsLibUtil.localForage.setItem("gh.meta.".concat(key), {
            expires: Date.now() + 300000,
            // In 5 minutes
            data
          });

          (_this$_metadataSemaph2 = this._metadataSemaphore) === null || _this$_metadataSemaph2 === void 0 ? void 0 : _this$_metadataSemaph2.leave();
          resolve();
        } catch (err) {
          reject(err);
        }
      });
    });
  }

  deleteMetadata(key) {
    if (!this._metadataSemaphore) {
      this._metadataSemaphore = (0, _semaphore.default)(1);
    }

    return new Promise(resolve => {
      var _this$_metadataSemaph3;

      return (_this$_metadataSemaph3 = this._metadataSemaphore) === null || _this$_metadataSemaph3 === void 0 ? void 0 : _this$_metadataSemaph3.take(async () => {
        try {
          var _this$_metadataSemaph4;

          const branchData = await this.checkMetadataRef();
          const file = {
            path: "".concat(key, ".json"),
            sha: null
          };
          const changeTree = await this.updateTree(branchData.sha, [file]);
          const {
            sha
          } = await this.commit("Deleting \u201C".concat(key, "\u201D metadata"), changeTree);
          await this.patchRef('meta', '_netlify_cms', sha);
          (_this$_metadataSemaph4 = this._metadataSemaphore) === null || _this$_metadataSemaph4 === void 0 ? void 0 : _this$_metadataSemaph4.leave();
          resolve();
        } catch (err) {
          var _this$_metadataSemaph5;

          (_this$_metadataSemaph5 = this._metadataSemaphore) === null || _this$_metadataSemaph5 === void 0 ? void 0 : _this$_metadataSemaph5.leave();
          resolve();
        }
      });
    });
  }

  retrieveMetadata(key) {
    const cache = _netlifyCmsLibUtil.localForage.getItem("gh.meta.".concat(key));

    return cache.then(cached => {
      if (cached && cached.expires > Date.now()) {
        return cached.data;
      }

      console.log('%c Checking for MetaData files', 'line-height: 30px;text-align: center;font-weight: bold');
      const metadataRequestOptions = {
        params: {
          ref: 'refs/meta/_netlify_cms'
        },
        headers: {
          Accept: 'application/vnd.github.v3.raw'
        },
        cache: 'no-store'
      };

      const errorHandler = err => {
        if (err.message === 'Not Found') {
          console.log('%c %s does not have metadata', 'line-height: 30px;text-align: center;font-weight: bold', key);
        }

        throw err;
      };

      if (!this.useOpenAuthoring) {
        return this.request("".concat(this.repoURL, "/contents/").concat(key, ".json"), metadataRequestOptions).then(response => JSON.parse(response)).catch(errorHandler);
      }

      const [user, repo] = key.split('/');
      return this.request("/repos/".concat(user, "/").concat(repo, "/contents/").concat(key, ".json"), metadataRequestOptions).then(response => JSON.parse(response)).catch(errorHandler);
    });
  }

  async readFile(path, sha, {
    branch = this.branch,
    repoURL = this.repoURL,
    parseText = true
  } = {}) {
    if (!sha) {
      sha = await this.getFileSha(path, {
        repoURL,
        branch
      });
    }

    const fetchContent = () => this.fetchBlobContent({
      sha: sha,
      repoURL,
      parseText
    });

    const content = await (0, _netlifyCmsLibUtil.readFile)(sha, fetchContent, _netlifyCmsLibUtil.localForage, parseText);
    return content;
  }

  async fetchBlobContent({
    sha,
    repoURL,
    parseText
  }) {
    const result = await this.request("".concat(repoURL, "/git/blobs/").concat(sha));

    if (parseText) {
      // treat content as a utf-8 string
      const content = _jsBase.Base64.decode(result.content);

      return content;
    } else {
      // treat content as binary and convert to blob
      const content = _jsBase.Base64.atob(result.content);

      const byteArray = new Uint8Array(content.length);

      for (let i = 0; i < content.length; i++) {
        byteArray[i] = content.charCodeAt(i);
      }

      const blob = new Blob([byteArray]);
      return blob;
    }
  }

  async listFiles(path, {
    repoURL = this.repoURL,
    branch = this.branch,
    depth = 1
  } = {}) {
    const folder = (0, _trim2.default)(path, '/');
    return this.request("".concat(repoURL, "/git/trees/").concat(branch, ":").concat(folder), {
      // GitHub API supports recursive=1 for getting the entire recursive tree
      // or omitting it to get the non-recursive tree
      params: depth > 1 ? {
        recursive: 1
      } : {}
    }).then(res => res.tree // filter only files and up to the required depth
    .filter(file => file.type === 'blob' && file.path.split('/').length <= depth).map(file => ({
      type: file.type,
      id: file.sha,
      name: (0, _netlifyCmsLibUtil.basename)(file.path),
      path: "".concat(folder, "/").concat(file.path),
      size: file.size
    }))).catch(replace404WithEmptyArray);
  }

  async readUnpublishedBranchFile(contentKey) {
    try {
      const metaData = await this.retrieveMetadata(contentKey).then(data => data.objects.entry.path ? data : Promise.reject(null));
      const repoURL = this.useOpenAuthoring ? "/repos/".concat(contentKey.split('/').slice(0, 2).join('/')) : this.repoURL;
      const [fileData, isModification] = await Promise.all([this.readFile(metaData.objects.entry.path, null, {
        branch: metaData.branch,
        repoURL
      }), this.isUnpublishedEntryModification(metaData.objects.entry.path)]);
      return {
        metaData,
        fileData,
        isModification,
        slug: this.slugFromContentKey(contentKey, metaData.collection)
      };
    } catch (e) {
      throw new _netlifyCmsLibUtil.EditorialWorkflowError('content is not under editorial workflow', true);
    }
  }

  isUnpublishedEntryModification(path) {
    return this.readFile(path, null, {
      branch: this.branch,
      repoURL: this.originRepoURL
    }).then(() => true).catch(err => {
      if (err.message && err.message === 'Not Found') {
        return false;
      }

      throw err;
    });
  }

  async migrateToVersion1(branch, metaData) {
    // hard code key/branch generation logic to ignore future changes
    const oldContentKey = branch.ref.substring("refs/heads/cms/".length);
    const newContentKey = "".concat(metaData.collection, "/").concat(oldContentKey);
    const newBranchName = "cms/".concat(newContentKey); // create new branch and pull request in new format

    const newBranch = await this.createBranch(newBranchName, metaData.pr.head);
    const pr = await this.createPR(metaData.commitMessage, newBranchName); // store new metadata

    await this.storeMetadata(newContentKey, _objectSpread({}, metaData, {
      pr: {
        number: pr.number,
        head: pr.head.sha
      },
      branch: newBranchName,
      version: '1'
    })); // remove old data

    await this.closePR(metaData.pr);
    await this.deleteBranch(metaData.branch);
    await this.deleteMetadata(oldContentKey);
    return newBranch;
  }

  async migrateBranch(branch) {
    const metadata = await this.retrieveMetadata(this.contentKeyFromRef(branch.ref));

    if (!metadata.version) {
      // migrate branch from cms/slug to cms/collection/slug
      branch = await this.migrateToVersion1(branch, metadata);
    }

    return branch;
  }

  async listUnpublishedBranches() {
    console.log('%c Checking for Unpublished entries', 'line-height: 30px;text-align: center;font-weight: bold');

    try {
      const branches = await this.request("".concat(this.repoURL, "/git/refs/heads/cms")).catch(replace404WithEmptyArray);
      let filterFunction;

      if (this.useOpenAuthoring) {
        const getUpdatedOpenAuthoringBranches = (0, _flow2.default)([(0, _map2.default)(async branch => {
          const contentKey = this.contentKeyFromRef(branch.ref);
          const metadata = await this.getUpdatedOpenAuthoringMetadata(contentKey); // filter out removed entries

          if (!metadata) {
            return Promise.reject('Unpublished entry was removed');
          }

          return branch;
        }), _netlifyCmsLibUtil.onlySuccessfulPromises]);
        filterFunction = getUpdatedOpenAuthoringBranches;
      } else {
        const prs = await this.getPRsForBranchName(_netlifyCmsLibUtil.CMS_BRANCH_PREFIX);
        const onlyBranchesWithOpenPRs = (0, _netlifyCmsLibUtil.flowAsync)([(0, _filter2.default)(({
          ref
        }) => prs.some(pr => pr.head.ref === this.branchNameFromRef(ref))), (0, _map2.default)(branch => this.migrateBranch(branch)), _netlifyCmsLibUtil.onlySuccessfulPromises]);
        filterFunction = onlyBranchesWithOpenPRs;
      }

      return await filterFunction(branches);
    } catch (err) {
      console.log('%c No Unpublished entries', 'line-height: 30px;text-align: center;font-weight: bold');
      throw err;
    }
  }
  /**
   * Retrieve statuses for a given SHA. Unrelated to the editorial workflow
   * concept of entry "status". Useful for things like deploy preview links.
   */


  async getStatuses(sha) {
    try {
      const resp = await this.request("".concat(this.originRepoURL, "/commits/").concat(sha, "/status"));
      return resp.statuses.map(s => ({
        context: s.context,
        // eslint-disable-next-line @typescript-eslint/camelcase
        target_url: s.target_url,
        state: s.state === GitHubCommitStatusState.Success ? _netlifyCmsLibUtil.PreviewState.Success : _netlifyCmsLibUtil.PreviewState.Other
      }));
    } catch (err) {
      if (err && err.message && err.message === 'Ref not found') {
        return [];
      }

      throw err;
    }
  }

  async persistFiles(entry, mediaFiles, options) {
    const files = entry ? mediaFiles.concat(entry) : mediaFiles;
    const uploadPromises = files.map(file => this.uploadBlob(file));
    await Promise.all(uploadPromises);

    if (!options.useWorkflow) {
      return this.getDefaultBranch().then(branchData => this.updateTree(branchData.commit.sha, files)).then(changeTree => this.commit(options.commitMessage, changeTree)).then(response => this.patchBranch(this.branch, response.sha));
    } else {
      const mediaFilesList = mediaFiles.map(({
        sha,
        path
      }) => ({
        path: (0, _trimStart2.default)(path, '/'),
        sha
      }));
      return this.editorialWorkflowGit(files, entry, mediaFilesList, options);
    }
  }

  getFileSha(path, {
    repoURL = this.repoURL,
    branch = this.branch
  } = {}) {
    /**
     * We need to request the tree first to get the SHA. We use extended SHA-1
     * syntax (<rev>:<path>) to get a blob from a tree without having to recurse
     * through the tree.
     */
    const pathArray = path.split('/');
    const filename = (0, _last2.default)(pathArray);
    const directory = (0, _initial2.default)(pathArray).join('/');
    const fileDataPath = encodeURIComponent(directory);
    const fileDataURL = "".concat(repoURL, "/git/trees/").concat(branch, ":").concat(fileDataPath);
    return this.request(fileDataURL, {
      cache: 'no-store'
    }).then(resp => {
      const file = resp.tree.find(file => file.path === filename);

      if (file) {
        return file.sha;
      }

      throw new _netlifyCmsLibUtil.APIError('Not Found', 404, API_NAME);
    });
  }

  deleteFile(path, message) {
    if (this.useOpenAuthoring) {
      return Promise.reject('Cannot delete published entries as an Open Authoring user!');
    }

    const branch = this.branch;
    return this.getFileSha(path, {
      branch
    }).then(sha => {
      const params = {
        sha,
        message,
        branch
      };
      const opts = {
        method: 'DELETE',
        params
      };

      if (this.commitAuthor) {
        opts.params.author = _objectSpread({}, this.commitAuthor, {
          date: new Date().toISOString()
        });
      }

      const fileURL = "".concat(this.repoURL, "/contents/").concat(path);
      return this.request(fileURL, opts);
    });
  }

  async createBranchAndPullRequest(branchName, sha, commitMessage) {
    await this.createBranch(branchName, sha);
    return this.createPR(commitMessage, branchName);
  }

  async editorialWorkflowGit(files, entry, mediaFilesList, options) {
    const contentKey = this.generateContentKey(options.collectionName, entry.slug);
    const branchName = this.generateBranchName(contentKey);
    const unpublished = options.unpublished || false;

    if (!unpublished) {
      // Open new editorial review workflow for this entry - Create new metadata and commit to new branch
      const userPromise = this.user();
      const branchData = await this.getDefaultBranch();
      const changeTree = await this.updateTree(branchData.commit.sha, files);
      const commitResponse = await this.commit(options.commitMessage, changeTree);
      let pr;

      if (this.useOpenAuthoring) {
        await this.createBranch(branchName, commitResponse.sha);
      } else {
        pr = await this.createBranchAndPullRequest(branchName, commitResponse.sha, options.commitMessage);
      }

      const user = await userPromise;
      return this.storeMetadata(contentKey, {
        type: 'PR',
        pr: pr ? {
          number: pr.number,
          head: pr.head && pr.head.sha
        } : undefined,
        user: user.name || user.login,
        status: options.status || this.initialWorkflowStatus,
        branch: branchName,
        collection: options.collectionName,
        commitMessage: options.commitMessage,
        title: options.parsedData && options.parsedData.title,
        description: options.parsedData && options.parsedData.description,
        objects: {
          entry: {
            path: entry.path,
            sha: entry.sha
          },
          files: mediaFilesList
        },
        timeStamp: new Date().toISOString(),
        version: CURRENT_METADATA_VERSION
      });
    } else {
      // Entry is already on editorial review workflow - just update metadata and commit to existing branch
      const metadata = await this.retrieveMetadata(contentKey); // mark media files to remove

      const metadataMediaFiles = (0, _get2.default)(metadata, 'objects.files', []);
      const mediaFilesToRemove = (0, _differenceBy2.default)(metadataMediaFiles, mediaFilesList, 'path').map(file => _objectSpread({}, file, {
        type: 'blob',
        sha: null
      })); // rebase the branch before applying new changes

      const rebasedHead = await this.rebaseBranch(branchName);
      const treeFiles = mediaFilesToRemove.concat(files);
      const changeTree = await this.updateTree(rebasedHead.sha, treeFiles);
      const commit = await this.commit(options.commitMessage, changeTree);
      const {
        title,
        description
      } = options.parsedData || {};
      const pr = metadata.pr ? _objectSpread({}, metadata.pr, {
        head: commit.sha
      }) : undefined;
      const objects = {
        entry: {
          path: entry.path,
          sha: entry.sha
        },
        files: mediaFilesList
      };

      const updatedMetadata = _objectSpread({}, metadata, {
        pr,
        title,
        description,
        objects
      });

      await this.storeMetadata(contentKey, updatedMetadata);
      return this.patchBranch(branchName, commit.sha, {
        force: true
      });
    }
  }

  async compareBranchToDefault(branchName) {
    const headReference = await this.getHeadReference(branchName);
    const {
      base_commit: baseCommit,
      commits
    } = await this.request("".concat(this.originRepoURL, "/compare/").concat(this.branch, "...").concat(headReference));
    return {
      baseCommit,
      commits
    };
  }

  async getCommitsDiff(baseSha, headSha) {
    const {
      files
    } = await this.request("".concat(this.repoURL, "/compare/").concat(baseSha, "...").concat(headSha));
    return files;
  }

  async rebaseSingleCommit(baseCommit, commit) {
    // first get the diff between the commits
    const files = await this.getCommitsDiff(commit.parents[0].sha, commit.sha);
    const treeFiles = files.reduce((arr, file) => {
      if (file.status === 'removed') {
        // delete the file
        arr.push({
          sha: null,
          path: file.filename
        });
      } else if (file.status === 'renamed') {
        // delete the previous file
        arr.push({
          sha: null,
          path: file.previous_filename
        }); // add the renamed file

        arr.push({
          sha: file.sha,
          path: file.filename
        });
      } else {
        // add the  file
        arr.push({
          sha: file.sha,
          path: file.filename
        });
      }

      return arr;
    }, []); // create a tree with baseCommit as the base with the diff applied

    const tree = await this.updateTree(baseCommit.sha, treeFiles);
    const {
      message,
      author,
      committer
    } = commit.commit; // create a new commit from the updated tree

    return this.createCommit(message, tree.sha, [baseCommit.sha], author, committer);
  }
  /**
   * Rebase an array of commits one-by-one, starting from a given base SHA
   */


  async rebaseCommits(baseCommit, commits) {
    /**
     * If the parent of the first commit already matches the target base,
     * return commits as is.
     */
    if (commits.length === 0 || commits[0].parents[0].sha === baseCommit.sha) {
      const head = (0, _last2.default)(commits);
      return head;
    } else {
      /**
       * Re-create each commit over the new base, applying each to the previous,
       * changing only the parent SHA and tree for each, but retaining all other
       * info, such as the author/committer data.
       */
      const newHeadPromise = commits.reduce((lastCommitPromise, commit) => {
        return lastCommitPromise.then(newParent => {
          const parent = newParent;
          const commitToRebase = commit;
          return this.rebaseSingleCommit(parent, commitToRebase);
        });
      }, Promise.resolve(baseCommit));
      return newHeadPromise;
    }
  }

  async rebaseBranch(branchName) {
    try {
      // Get the diff between the default branch the published branch
      const {
        baseCommit,
        commits
      } = await this.compareBranchToDefault(branchName); // Rebase the branch based on the diff

      const rebasedHead = await this.rebaseCommits(baseCommit, commits);
      return rebasedHead;
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
  /**
   * Get a pull request by PR number.
   */


  getPullRequest(prNumber) {
    return this.request("".concat(this.originRepoURL, "/pulls/").concat(prNumber, " }"));
  }

  async updateUnpublishedEntryStatus(collectionName, slug, status) {
    const contentKey = this.generateContentKey(collectionName, slug);
    const metadata = await this.retrieveMetadata(contentKey);

    if (!this.useOpenAuthoring) {
      return this.storeMetadata(contentKey, _objectSpread({}, metadata, {
        status
      }));
    }

    if (status === 'pending_publish') {
      throw new Error('Open Authoring entries may not be set to the status "pending_publish".');
    }

    const {
      pr: prMetadata
    } = metadata;

    if (prMetadata) {
      const {
        number: prNumber
      } = prMetadata;
      const originPRInfo = await this.getPullRequest(prNumber);
      const {
        state
      } = originPRInfo;

      if (state === 'open' && status === 'draft') {
        await this.closePR(prMetadata);
        return this.storeMetadata(contentKey, _objectSpread({}, metadata, {
          status
        }));
      }

      if (state === 'closed' && status === 'pending_review') {
        await this.openPR(prMetadata);
        return this.storeMetadata(contentKey, _objectSpread({}, metadata, {
          status
        }));
      }
    }

    if (!prMetadata && status === 'pending_review') {
      const branchName = this.generateBranchName(contentKey);
      const commitMessage = metadata.commitMessage || API.DEFAULT_COMMIT_MESSAGE;
      const {
        number,
        head
      } = await this.createPR(commitMessage, branchName);
      return this.storeMetadata(contentKey, _objectSpread({}, metadata, {
        pr: {
          number,
          head
        },
        status
      }));
    }
  }

  async deleteUnpublishedEntry(collectionName, slug) {
    const contentKey = this.generateContentKey(collectionName, slug);
    const branchName = this.generateBranchName(contentKey);
    return this.retrieveMetadata(contentKey).then(metadata => metadata && metadata.pr ? this.closePR(metadata.pr) : Promise.resolve()).then(() => this.deleteBranch(branchName)).then(() => this.deleteMetadata(contentKey));
  }

  async publishUnpublishedEntry(collectionName, slug) {
    const contentKey = this.generateContentKey(collectionName, slug);
    const branchName = this.generateBranchName(contentKey);
    const metadata = await this.retrieveMetadata(contentKey);
    await this.mergePR(metadata.pr, metadata.objects);
    await this.deleteBranch(branchName);
    await this.deleteMetadata(contentKey);
    return metadata;
  }

  createRef(type, name, sha) {
    return this.request("".concat(this.repoURL, "/git/refs"), {
      method: 'POST',
      body: JSON.stringify({
        ref: "refs/".concat(type, "/").concat(name),
        sha
      })
    });
  }

  patchRef(type, name, sha, opts = {}) {
    const force = opts.force || false;
    return this.request("".concat(this.repoURL, "/git/refs/").concat(type, "/").concat(encodeURIComponent(name)), {
      method: 'PATCH',
      body: JSON.stringify({
        sha,
        force
      })
    });
  }

  deleteRef(type, name) {
    return this.request("".concat(this.repoURL, "/git/refs/").concat(type, "/").concat(encodeURIComponent(name)), {
      method: 'DELETE'
    });
  }

  getDefaultBranch() {
    return this.request("".concat(this.originRepoURL, "/branches/").concat(encodeURIComponent(this.branch)));
  }

  createBranch(branchName, sha) {
    return this.createRef('heads', branchName, sha);
  }

  assertCmsBranch(branchName) {
    return branchName.startsWith("".concat(_netlifyCmsLibUtil.CMS_BRANCH_PREFIX, "/"));
  }

  patchBranch(branchName, sha, opts = {}) {
    const force = opts.force || false;

    if (force && !this.assertCmsBranch(branchName)) {
      throw Error("Only CMS branches can be force updated, cannot force update ".concat(branchName));
    }

    return this.patchRef('heads', branchName, sha, {
      force
    });
  }

  deleteBranch(branchName) {
    return this.deleteRef('heads', branchName).catch(err => {
      // If the branch doesn't exist, then it has already been deleted -
      // deletion should be idempotent, so we can consider this a
      // success.
      if (err.message === 'Reference does not exist') {
        return Promise.resolve();
      }

      console.error(err);
      return Promise.reject(err);
    });
  }

  async getHeadReference(head) {
    const headReference = this.useOpenAuthoring ? "".concat((await this.user()).login, ":").concat(head) : head;
    return headReference;
  }

  async createPR(title, head) {
    const headReference = await this.getHeadReference(head);
    return this.request("".concat(this.originRepoURL, "/pulls"), {
      method: 'POST',
      body: JSON.stringify({
        title,
        body: _netlifyCmsLibUtil.DEFAULT_PR_BODY,
        head: headReference,
        base: this.branch
      })
    });
  }

  async openPR(pullRequest) {
    const {
      number
    } = pullRequest;
    console.log('%c Re-opening PR', 'line-height: 30px;text-align: center;font-weight: bold');
    return this.request("".concat(this.originRepoURL, "/pulls/").concat(number), {
      method: 'PATCH',
      body: JSON.stringify({
        state: 'open'
      })
    });
  }

  closePR(pullRequest) {
    const {
      number
    } = pullRequest;
    console.log('%c Deleting PR', 'line-height: 30px;text-align: center;font-weight: bold');
    return this.request("".concat(this.originRepoURL, "/pulls/").concat(number), {
      method: 'PATCH',
      body: JSON.stringify({
        state: 'closed'
      })
    });
  }

  mergePR(pullrequest, objects) {
    const {
      head: headSha,
      number
    } = pullrequest;
    console.log('%c Merging PR', 'line-height: 30px;text-align: center;font-weight: bold');
    return this.request("".concat(this.originRepoURL, "/pulls/").concat(number, "/merge"), {
      method: 'PUT',
      body: JSON.stringify({
        // eslint-disable-next-line @typescript-eslint/camelcase
        commit_message: _netlifyCmsLibUtil.MERGE_COMMIT_MESSAGE,
        sha: headSha,
        // eslint-disable-next-line @typescript-eslint/camelcase
        merge_method: this.mergeMethod
      })
    }).catch(error => {
      if (error instanceof _netlifyCmsLibUtil.APIError && error.status === 405) {
        return this.forceMergePR(objects);
      } else {
        throw error;
      }
    });
  }

  forceMergePR(objects) {
    const files = objects.files.concat(objects.entry);
    let commitMessage = 'Automatically generated. Merged on Netlify CMS\n\nForce merge of:';
    files.forEach(file => {
      commitMessage += "\n* \"".concat(file.path, "\"");
    });
    console.log('%c Automatic merge not possible - Forcing merge.', 'line-height: 30px;text-align: center;font-weight: bold');
    return this.getDefaultBranch().then(branchData => this.updateTree(branchData.commit.sha, files)).then(changeTree => this.commit(commitMessage, changeTree)).then(response => this.patchBranch(this.branch, response.sha));
  }

  toBase64(str) {
    return Promise.resolve(_jsBase.Base64.encode(str));
  }

  uploadBlob(item) {
    const content = (0, _result2.default)(item, 'toBase64', (0, _partial2.default)(this.toBase64, item.raw));
    return content.then(contentBase64 => this.request("".concat(this.repoURL, "/git/blobs"), {
      method: 'POST',
      body: JSON.stringify({
        content: contentBase64,
        encoding: 'base64'
      })
    }).then(response => {
      item.sha = response.sha;
      return item;
    }));
  }

  async updateTree(baseSha, files) {
    const tree = files.map(file => ({
      path: (0, _trimStart2.default)(file.path, '/'),
      mode: '100644',
      type: 'blob',
      sha: file.sha
    }));
    const newTree = await this.createTree(baseSha, tree);
    return _objectSpread({}, newTree, {
      parentSha: baseSha
    });
  }

  createTree(baseSha, tree) {
    return this.request("".concat(this.repoURL, "/git/trees"), {
      method: 'POST',
      // eslint-disable-next-line @typescript-eslint/camelcase
      body: JSON.stringify({
        base_tree: baseSha,
        tree
      })
    });
  }

  commit(message, changeTree) {
    const parents = changeTree.parentSha ? [changeTree.parentSha] : [];
    return this.createCommit(message, changeTree.sha, parents);
  }

  createCommit(message, treeSha, parents, author, committer) {
    return this.request("".concat(this.repoURL, "/git/commits"), {
      method: 'POST',
      body: JSON.stringify({
        message,
        tree: treeSha,
        parents,
        author,
        committer
      })
    });
  }

}

exports.default = API;

_defineProperty(API, "DEFAULT_COMMIT_MESSAGE", 'Automatically generated by Netlify CMS');