'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.publishEntities = publishEntities;
exports.archiveEntities = archiveEntities;

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _getEntityName = require('contentful-batch-libs/dist/get-entity-name');

var _getEntityName2 = _interopRequireDefault(_getEntityName);

var _logging = require('contentful-batch-libs/dist/logging');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Publish a list of entities.
 * Does not return a rejected promise in the case of an error, pushing it
 * to an error buffer instead.
 */
function publishEntities(entities) {
  const entitiesToPublish = entities.filter(entity => {
    if (!entity || !entity.publish) {
      _logging.logEmitter.emit('warning', `Unable to publish ${(0, _getEntityName2.default)(entity)}`);
      return false;
    }
    return true;
  });

  if (entitiesToPublish.length === 0) {
    _logging.logEmitter.emit('info', 'Skipping publishing since zero valid entities passed');
    return _bluebird2.default.resolve([]);
  }

  const entity = entities[0].original || entities[0];
  const type = entity.sys.type || 'unknown type';
  _logging.logEmitter.emit('info', `Publishing ${entities.length} ${type}s`);

  return runQueue(entitiesToPublish).then(result => {
    _logging.logEmitter.emit('info', `Successfully published ${result.length} ${type}s`);
    return result;
  });
}

function archiveEntities(entities) {
  const entitiesToArchive = entities.filter(entity => {
    if (!entity || !entity.archive) {
      _logging.logEmitter.emit('warning', `Unable to archive ${(0, _getEntityName2.default)(entity)}`);
      return false;
    }
    return true;
  });

  if (entitiesToArchive.length === 0) {
    _logging.logEmitter.emit('info', 'Skipping archiving since zero valid entities passed');
    return _bluebird2.default.resolve([]);
  }

  const entity = entities[0].original || entities[0];
  const type = entity.sys.type || 'unknown type';
  _logging.logEmitter.emit('info', `Archiving ${entities.length} ${type}s`);

  return _bluebird2.default.map(entitiesToArchive, entity => {
    return entity.archive().then(entity => {
      return entity;
    }, err => {
      err.entity = entity;
      _logging.logEmitter.emit('error', err);
      return null;
    });
  }).then(result => {
    _logging.logEmitter.emit('info', `Successfully archived ${result.length} ${type}s`);
    return result;
  });
}

function runQueue(queue, result) {
  if (!result) {
    result = [];
  }
  return _bluebird2.default.map(queue, (entity, index) => {
    _logging.logEmitter.emit('info', `Publishing ${entity.sys.type} ${(0, _getEntityName2.default)(entity)}`);
    return entity.publish().then(entity => {
      return entity;
    }, err => {
      err.entity = entity;
      _logging.logEmitter.emit('error', err);
      return null;
    });
  }, { concurrency: 1 }).then(entities => entities.filter(entity => entity)).then(publishedEntities => {
    result = [...result, ...publishedEntities];
    const publishedEntityIds = publishedEntities.map(entitiy => entitiy.sys.id);
    const unpublishedEntities = queue.filter(entity => publishedEntityIds.indexOf(entity.sys.id) === -1);
    return unpublishedEntities;
  }).then(unpublishedEntities => {
    if (unpublishedEntities.length > 0) {
      if (queue.length === unpublishedEntities.length) {
        // Fail when queue could not publish at least one item
        const unpublishedEntityNames = unpublishedEntities.map(_getEntityName2.default).join(', ');
        _logging.logEmitter.emit('error', `Could not publish the following entities: ${unpublishedEntityNames}`);
      } else {
        // Rerun queue with unpublished entities
        return runQueue(unpublishedEntities, result);
      }
    }
    // Return only published entities + last result
    return result;
  });
}