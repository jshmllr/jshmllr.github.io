"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const field_deletion_1 = __importDefault(require("./validator/field-deletion"));
const content_type_1 = require("../entities/content-type");
const entry_1 = require("../entities/entry");
const display_field_1 = __importDefault(require("./validator/display-field"));
const index_1 = __importDefault(require("./validator/schema/index"));
const type_change_1 = __importDefault(require("./validator/type-change"));
const link_1 = __importDefault(require("../entities/link"));
var ApiHook;
(function (ApiHook) {
    ApiHook["SaveContentType"] = "SAVE_CONTENT_TYPE";
    ApiHook["PublishContentType"] = "PUBLISH_CONTENT_TYPE";
    ApiHook["UnpublishContentType"] = "UNPUBLISH_CONTENT_TYPE";
    ApiHook["DeleteContentType"] = "DELETE_CONTENT_TYPE";
})(ApiHook = exports.ApiHook || (exports.ApiHook = {}));
const saveContentTypeRequest = function (ct) {
    return {
        method: 'PUT',
        url: `/content_types/${ct.id}`,
        headers: {
            'X-Contentful-Version': ct.version
        },
        data: lodash_1.omit(ct.toAPI(), 'sys')
    };
};
const saveEntryRequest = function (entry) {
    return {
        method: 'PUT',
        url: `/entries/${entry.id}`,
        headers: {
            'X-Contentful-Version': entry.version,
            'X-Contentful-Content-Type': entry.contentTypeId
        },
        data: entry.toApiEntry()
    };
};
const publishEntryRequest = function (entry) {
    return {
        method: 'PUT',
        url: `/entries/${entry.id}/published`,
        headers: {
            'X-Contentful-Version': entry.version,
            'X-Contentful-Content-Type': entry.contentTypeId
        }
    };
};
const unpublishEntryRequest = function (entry) {
    return {
        method: 'DELETE',
        url: `/entries/${entry.id}/published`,
        headers: {
            'X-Contentful-Version': entry.version
        }
    };
};
const deleteEntryRequest = function (entry) {
    return {
        method: 'DELETE',
        url: `/entries/${entry.id}`,
        headers: {
            'X-Contentful-Version': entry.version
        }
    };
};
const publishContentTypeRequest = function (ct) {
    return {
        method: 'PUT',
        url: `/content_types/${ct.id}/published`,
        headers: {
            'X-Contentful-Version': ct.version
        }
    };
};
const unpublishRequest = function (ct) {
    return {
        method: 'DELETE',
        url: `/content_types/${ct.id}/published`,
        headers: {
            'X-Contentful-Version': ct.version
        }
    };
};
const deleteRequest = function (ct) {
    return {
        method: 'DELETE',
        url: `/content_types/${ct.id}`,
        headers: {
            'X-Contentful-Version': ct.version
        }
    };
};
const saveEditorInterfacesRequest = function (contentTypeId, editorInterfaces) {
    return {
        method: 'PUT',
        url: `/content_types/${contentTypeId}/editor_interface`,
        headers: {
            'X-Contentful-Version': editorInterfaces.version
        },
        data: editorInterfaces.toAPI()
    };
};
class OfflineAPI {
    constructor(contentTypes = new Map(), entries = [], locales, editorInterfacesByContentType = new Map()) {
        this.modifiedContentTypes = null;
        this.savedContentTypes = null;
        this.publishedContentTypes = null;
        this.editorInterfaces = null;
        this.entries = null;
        this.isRecordingRequests = false;
        this.currentRequestsRecorded = null;
        this.currentValidationErrorsRecorded = null;
        this.intent = null;
        this.requestBatches = [];
        this.contentTypeValidators = [];
        this.locales = [];
        this.modifiedContentTypes = contentTypes;
        // Initialize saved and published state
        // These are (currently) exclusively needed for stateful validations
        // for example "cannot delete before omitted was published"
        //
        // Since the `modifiedContentTypes` are mutable,
        // we need to perform a clone.
        // TODO: Build a better abstraction over `Map` that allows easy cloning
        // and also allows us to implement async iterators
        this.savedContentTypes = new Map();
        this.publishedContentTypes = new Map();
        this.editorInterfaces = editorInterfacesByContentType;
        for (const [id, contentType] of contentTypes.entries()) {
            this.savedContentTypes.set(id, contentType.clone());
            this.publishedContentTypes.set(id, contentType.clone());
        }
        this.contentTypeValidators.push(new field_deletion_1.default());
        this.contentTypeValidators.push(new display_field_1.default());
        this.contentTypeValidators.push(new index_1.default());
        this.contentTypeValidators.push(new type_change_1.default());
        this.entries = entries;
        this.locales = locales;
    }
    async getContentType(id) {
        if (!this.hasContentType(id)) {
            throw new Error(`Cannot get Content Type ${id} because it does not exist`);
        }
        return this.modifiedContentTypes.get(id);
    }
    async getEditorInterfaces(contentTypeId) {
        if (!this.editorInterfaces.has(contentTypeId)) {
            throw new Error(`Cannot get editor interfaces for Content Type ${contentTypeId} because it does not exist`);
        }
        return this.editorInterfaces.get(contentTypeId);
    }
    async hasContentType(id) {
        return this.modifiedContentTypes.has(id);
    }
    async createContentType(id) {
        this.assertRecording();
        const ct = new content_type_1.ContentType({ sys: { id, version: 0 }, fields: [], name: undefined });
        await this.modifiedContentTypes.set(id, ct);
        return ct;
    }
    async saveContentType(id) {
        this.assertRecording();
        const hasContentType = this.modifiedContentTypes.has(id);
        if (!hasContentType) {
            throw new Error(`Cannot save the content type (id: ${id}) because it does not exist`);
        }
        const ct = await this.getContentType(id);
        // Store clone as a request
        this.currentRequestsRecorded.push(saveContentTypeRequest(ct.clone()));
        // Mutate version bump
        ct.version = ct.version + 1;
        await this.modifiedContentTypes.set(id, ct);
        await this.savedContentTypes.set(id, ct.clone());
        for (const validator of this.contentTypeValidators) {
            if (validator.hooks.includes(ApiHook.SaveContentType)) {
                const errors = validator.validate(ct, this.savedContentTypes.get(id), this.publishedContentTypes.get(id));
                this.currentValidationErrorsRecorded = this.currentValidationErrorsRecorded.concat(errors);
            }
        }
        return ct;
    }
    async publishContentType(id) {
        this.assertRecording();
        const ct = await this.getContentType(id);
        // Store clone as a request
        this.currentRequestsRecorded.push(publishContentTypeRequest(ct.clone()));
        // Mutate version bump
        ct.version = ct.version + 1;
        await this.modifiedContentTypes.set(id, ct);
        await this.savedContentTypes.set(id, ct.clone());
        await this.publishedContentTypes.set(id, ct.clone());
        if (this.editorInterfaces.has(id)) {
            const editorInterfaces = this.editorInterfaces.get(id);
            editorInterfaces.version = editorInterfaces.version + 1;
        }
        for (const validator of this.contentTypeValidators) {
            if (validator.hooks.includes(ApiHook.PublishContentType)) {
                const errors = validator.validate(ct, this.savedContentTypes.get(id), this.publishedContentTypes.get(id));
                this.currentValidationErrorsRecorded = this.currentValidationErrorsRecorded.concat(errors);
            }
        }
        return ct;
    }
    async unpublishContentType(id) {
        this.assertRecording();
        const ct = await this.getContentType(id);
        // Store clone as a request
        this.currentRequestsRecorded.push(unpublishRequest(ct.clone()));
        // Mutate version bump
        ct.version = ct.version + 1;
        await this.modifiedContentTypes.set(id, ct);
        await this.savedContentTypes.set(id, ct);
        await this.publishedContentTypes.delete(id);
        for (const validator of this.contentTypeValidators) {
            if (validator.hooks.includes(ApiHook.UnpublishContentType)) {
                const errors = validator.validate(ct, this.savedContentTypes.get(id), this.publishedContentTypes.get(id));
                this.currentValidationErrorsRecorded = this.currentValidationErrorsRecorded.concat(errors);
            }
        }
        return ct;
    }
    async deleteContentType(id) {
        this.assertRecording();
        const ct = await this.getContentType(id);
        // Store clone as a request
        this.currentRequestsRecorded.push(deleteRequest(ct.clone()));
        await this.modifiedContentTypes.delete(id);
        await this.publishedContentTypes.delete(id);
        await this.savedContentTypes.delete(id);
        for (const validator of this.contentTypeValidators) {
            if (validator.hooks.includes(ApiHook.DeleteContentType)) {
                const errors = validator.validate(ct, this.savedContentTypes.get(id), this.publishedContentTypes.get(id));
                this.currentValidationErrorsRecorded = this.currentValidationErrorsRecorded.concat(errors);
            }
        }
    }
    async saveEditorInterfaces(contentTypeId) {
        this.assertRecording();
        if (!this.editorInterfaces.has(contentTypeId)) {
            throw new Error(`Cannot save editor interfaces for Content Type ${contentTypeId} because they do not exist`);
        }
        const editorInterfaces = this.editorInterfaces.get(contentTypeId);
        this.currentRequestsRecorded.push(saveEditorInterfacesRequest(contentTypeId, editorInterfaces));
        editorInterfaces.version = editorInterfaces.version + 1;
        return editorInterfaces;
    }
    async createEntry(contentTypeId, id) {
        this.assertRecording();
        const entryData = {
            sys: {
                id,
                version: 0,
                contentType: {
                    sys: { type: 'Link', linkType: 'ContentType', id: contentTypeId }
                }
            },
            fields: {}
        };
        const entry = new entry_1.Entry(entryData);
        await this.entries.push(entry);
        return entry;
    }
    async saveEntry(id) {
        this.assertRecording();
        const hasEntry = await this.hasEntry(id);
        if (!hasEntry) {
            throw new Error(`Cannot save Entry ${id} because it does not exist`);
        }
        const entry = this.entries.find((entry) => entry.id === id);
        // Store clone as a request
        this.currentRequestsRecorded.push(saveEntryRequest(entry.clone()));
        // Mutate version bump
        entry.version = entry.version + 1;
        return entry;
    }
    async hasEntry(id) {
        return this.entries.some((entry) => entry.id === id);
    }
    async publishEntry(id) {
        this.assertRecording();
        const hasEntry = this.entries.some((entry) => entry.id === id);
        if (!hasEntry) {
            throw new Error(`Cannot publish Entry ${id} because it does not exist`);
        } // Store clone as a request
        const entry = this.entries.find((entry) => entry.id === id);
        this.currentRequestsRecorded.push(publishEntryRequest(entry.clone()));
        // Mutate version bump
        entry.publishedVersion = entry.version;
        entry.version = entry.version + 1;
        return entry;
    }
    async unpublishEntry(id) {
        this.assertRecording();
        const hasEntry = this.entries.some((entry) => entry.id === id);
        if (!hasEntry) {
            throw new Error(`Cannot unpublish Entry ${id} because it does not exist`);
        }
        const entry = this.entries.find((entry) => entry.id === id);
        // Store clone as a request
        this.currentRequestsRecorded.push(unpublishEntryRequest(entry.clone()));
        // Mutate version bump
        entry.publishedVersion = null;
        entry.version = entry.version + 1;
        return entry;
    }
    async deleteEntry(id) {
        this.assertRecording();
        const hasEntry = this.entries.some((entry) => entry.id === id);
        if (!hasEntry) {
            throw new Error(`Cannot delete Entry ${id} because it does not exist`);
        } // Store clone as a request
        const entry = this.entries.find((entry) => entry.id === id);
        const index = this.entries.indexOf(entry);
        this.entries.splice(index, 1);
        this.currentRequestsRecorded.push(deleteEntryRequest(entry.clone()));
        return entry;
    }
    async getEntriesForContentType(ctId) {
        const entries = this.entries.filter((entry) => entry.contentTypeId === ctId);
        return entries;
    }
    async getLinks(childId, locales) {
        const links = [];
        for (let entry of this.entries) {
            const fields = entry.fields;
            for (let key of Object.keys(fields)) {
                for (let locale of locales) {
                    const field = lodash_1.get(entry.fields, `${key}.${locale}`);
                    if (lodash_1.get(field, 'sys.id') === childId) {
                        links.push(new link_1.default(entry, key, locale));
                    }
                    if (field instanceof Array) {
                        const fieldArray = field;
                        fieldArray.forEach((fieldEntry, index) => {
                            if (lodash_1.get(fieldEntry, 'sys.id') === childId) {
                                links.push(new link_1.default(entry, key, locale, index));
                            }
                        });
                    }
                }
            }
        }
        return links;
    }
    async getLocalesForSpace() {
        return this.locales;
    }
    async startRecordingRequests(intent) {
        if (this.isRecordingRequests) {
            throw new Error('You need to stop recording before starting again');
        }
        this.isRecordingRequests = true;
        this.currentRequestsRecorded = [];
        this.currentValidationErrorsRecorded = [];
        this.currentRuntimeErrorsRecorded = [];
        this.intent = intent;
    }
    // Returns all requests that needed to happen
    // for all changes
    async stopRecordingRequests() {
        if (!this.isRecordingRequests) {
            throw new Error('You need to start recording before stopping');
        }
        const batch = {
            intent: this.intent,
            requests: this.currentRequestsRecorded,
            validationErrors: lodash_1.compact(this.currentValidationErrorsRecorded),
            runtimeErrors: this.currentRuntimeErrorsRecorded
        };
        this.requestBatches.push(batch);
        this.isRecordingRequests = false;
        this.currentRequestsRecorded = [];
        this.currentValidationErrorsRecorded = [];
        this.intent = null;
    }
    async getRequestBatches() {
        if (this.isRecordingRequests) {
            throw new Error('Cannot get batches while still recording');
        }
        return this.requestBatches;
    }
    async recordRuntimeError(error) {
        this.currentRuntimeErrorsRecorded.push(error);
    }
    assertRecording() {
        if (this.isRecordingRequests) {
            return;
        }
        throw new Error('You need to be recording to use the API methods.');
    }
}
exports.default = OfflineAPI;
exports.OfflineAPI = OfflineAPI;
//# sourceMappingURL=index.js.map