"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const migration_steps_1 = require("./migration-steps");
const validation_1 = __importDefault(require("./migration-chunks/validation"));
const content_type_1 = require("./entities/content-type");
const content_type_update_1 = __importDefault(require("./intent-validator/content-type-update"));
const field_update_1 = __importDefault(require("./intent-validator/field-update"));
const field_movement_1 = __importDefault(require("./intent-validator/field-movement"));
const entry_derive_1 = __importDefault(require("./intent-validator/entry-derive"));
const content_transform_1 = __importDefault(require("./intent-validator/content-transform"));
const intent_list_1 = __importDefault(require("./intent-list"));
const errors = __importStar(require("./errors/index"));
const entry_1 = __importDefault(require("./entities/entry"));
const fetcher_1 = __importDefault(require("./fetcher"));
const offline_api_1 = __importDefault(require("./offline-api"));
class ParseResult {
    constructor() {
        this.batches = [];
        this.stepsValidationErrors = [];
        this.payloadValidationErrors = [];
    }
    hasValidationErrors() {
        return this.batches.some(batch => batch.validationErrors.length > 0);
    }
    hasRuntimeErrors() {
        return this.batches.some(batch => batch.runtimeErrors.length > 0);
    }
    hasStepsValidationErrors() {
        return this.stepsValidationErrors.length > 0;
    }
    hasPayloadValidationErrors() {
        return this.payloadValidationErrors.length > 0;
    }
    getRuntimeErrors() {
        return this.batches.reduce((errors, batch) => {
            return errors.concat(batch.runtimeErrors);
        }, []);
    }
    getValidationErrors() {
        return this.batches.reduce((errors, batch) => {
            return errors.concat(batch.validationErrors);
        }, []);
    }
}
exports.ParseResult = ParseResult;
const createMigrationParser = function (makeRequest, config) {
    return async function migration(migrationCreator) {
        const fetcher = new fetcher_1.default(makeRequest);
        const parseResult = new ParseResult();
        const intents = await migration_steps_1.migration(migrationCreator, makeRequest, config);
        const intentList = new intent_list_1.default(intents);
        intentList.addValidator(new content_type_update_1.default());
        intentList.addValidator(new field_update_1.default());
        intentList.addValidator(new field_movement_1.default());
        intentList.addValidator(new content_transform_1.default());
        intentList.addValidator(new entry_derive_1.default());
        const stepsValidationErrors = intentList.validate();
        if (stepsValidationErrors.length) {
            parseResult.stepsValidationErrors = stepsValidationErrors;
            return parseResult;
        }
        let apiContentTypes;
        try {
            apiContentTypes = await fetcher.getContentTypesInChunks(intentList);
        }
        catch (error) {
            throw new errors.SpaceAccessError();
        }
        const existingCts = new Map();
        for (const apiCt of apiContentTypes) {
            const contentType = new content_type_1.ContentType(apiCt);
            existingCts.set(contentType.id, contentType);
        }
        let apiEditorInterfaces;
        try {
            apiEditorInterfaces = await fetcher.getEditorInterfacesInIntents(intentList);
        }
        catch (error) {
            throw new errors.EditorInterfacesFetchingError();
        }
        const existingEditorInterfaces = new Map();
        for (const [contentTypeId, apiEi] of apiEditorInterfaces) {
            const editorInterfaces = new content_type_1.EditorInterfaces(apiEi);
            existingEditorInterfaces.set(contentTypeId, editorInterfaces);
        }
        const contentTypes = apiContentTypes.map((apiCt) => {
            return new content_type_1.ContentType(apiCt);
        });
        let existingEntries;
        try {
            existingEntries = await fetcher.getEntriesInIntents(intentList);
        }
        catch (error) {
            throw new errors.SpaceAccessError();
        }
        const entries = existingEntries.map((apiEntry) => {
            return new entry_1.default(apiEntry);
        });
        const ctsWithEntryInfo = await fetcher.checkContentTypesForDeletedCts(intentList, contentTypes);
        const payloadValidationErrors = validation_1.default(intentList, ctsWithEntryInfo);
        if (payloadValidationErrors.length) {
            parseResult.payloadValidationErrors = payloadValidationErrors;
            return parseResult;
        }
        const locales = await fetcher.getLocalesForSpace();
        const api = new offline_api_1.default(existingCts, entries, locales, existingEditorInterfaces);
        await intentList.compressed().applyTo(api);
        const batches = await api.getRequestBatches();
        parseResult.batches = batches;
        return parseResult;
    };
};
exports.default = createMigrationParser;
exports.createMigrationParser = createMigrationParser;
//# sourceMappingURL=migration-parser.js.map