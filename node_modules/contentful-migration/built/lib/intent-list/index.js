"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const composed_intent_1 = __importDefault(require("../intent/composed-intent"));
const action_1 = require("../action/action");
const content_type_save_1 = require("../action/content-type-save");
const content_type_publish_1 = require("../action/content-type-publish");
class IntentList {
    constructor(intents) {
        this.validators = [];
        this.intents = intents;
    }
    addValidator(validator) {
        this.validators.push(validator);
    }
    validate() {
        let errors = [];
        for (const intent of this.getIntents()) {
            for (const validator of this.validators) {
                if (validator.appliesTo(intent)) {
                    const intentErrors = validator.validate(intent);
                    if (intentErrors.length) {
                        errors = errors.concat(intentErrors);
                    }
                }
            }
        }
        return errors;
    }
    toRaw() {
        return this.intents.map((intent) => intent.toRaw());
    }
    getIntents() {
        return this.intents;
    }
    compressed() {
        let composedIntents = [];
        let composableIntents = [];
        for (const intent of this.intents) {
            const lastComposableIntent = composableIntents.length ? composableIntents[composableIntents.length - 1] : null;
            if (lastComposableIntent === null || intent.groupsWith(lastComposableIntent)) {
                composableIntents.push(intent);
            }
            else {
                if (composableIntents.length === 1) {
                    // No need to compose a single intent, just append
                    composedIntents = composedIntents.concat(composableIntents);
                }
                else {
                    // Compose multiple intents into single intent
                    composedIntents.push(new composed_intent_1.default(composableIntents));
                }
                // Start new round of composable intents
                composableIntents = [intent];
            }
            // Sometimes the group needs to be closed after the current intent
            if (intent.endsGroup()) {
                if (composableIntents.length === 1) {
                    // No need to compose a single intent, just append
                    composedIntents = composedIntents.concat(composableIntents);
                }
                else {
                    // Compose multiple intents into single intent
                    composedIntents.push(new composed_intent_1.default(composableIntents));
                }
                composableIntents = [];
            }
        }
        if (composableIntents.length === 1) {
            composedIntents = composedIntents.concat(composableIntents);
        }
        if (composableIntents.length > 1) {
            composedIntents.push(new composed_intent_1.default(composableIntents));
        }
        return new IntentList(composedIntents);
    }
    async applyTo(api) {
        const intents = this.getIntents();
        for (const intent of intents) {
            // TODO give this a real name
            await api.startRecordingRequests(intent);
            for (const action of intent.toActions()) {
                if (action instanceof action_1.APIAction) {
                    await action.applyTo(api);
                    continue;
                }
                if (action instanceof action_1.EntityAction) {
                    const entityType = action.getEntityType();
                    const entityId = action.getEntityId();
                    if (entityType === 'CONTENT_TYPE') {
                        const ct = await api.getContentType(entityId);
                        await action.applyTo(ct);
                    }
                    if (entityType === 'EDITOR_INTERFACE') {
                        try {
                            const editorInterfaces = await api.getEditorInterfaces(entityId);
                            await action.applyTo(editorInterfaces);
                        }
                        catch (_a) {
                            // TODO: maybe a better handling
                        }
                    }
                    continue;
                }
            }
            // Auto insert publish and save
            if (intent.shouldSave()) {
                const save = new content_type_save_1.ContentTypeSaveAction(intent.getContentTypeId());
                await save.applyTo(api);
            }
            if (intent.shouldPublish()) {
                const publish = new content_type_publish_1.ContentTypePublishAction(intent.getContentTypeId());
                await publish.applyTo(api);
            }
            await api.stopRecordingRequests();
        }
    }
}
exports.default = IntentList;
//# sourceMappingURL=index.js.map