"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const inquirer = __importStar(require("inquirer"));
const listr_1 = __importDefault(require("listr"));
const contentful_client_1 = require("./lib/contentful-client");
const { version } = require('../../package.json');
const { SpaceAccessError } = require('../lib/errors');
const migration_parser_1 = __importDefault(require("../lib/migration-parser"));
const render_migration_1 = require("./lib/render-migration");
const steps_errors_1 = __importDefault(require("./lib/steps-errors"));
const write_errors_to_log_1 = __importDefault(require("./lib/write-errors-to-log"));
const config_1 = require("./lib/config");
class ManyError extends Error {
    constructor(message, errors) {
        super(message);
        this.errors = errors;
    }
}
class BatchError extends Error {
    constructor(message, batch, errors) {
        super(message);
        this.batch = batch;
        this.errors = errors;
    }
}
const makeTerminatingFunction = ({ shouldThrow }) => (error) => {
    if (shouldThrow) {
        throw error;
    }
    else {
        process.exit(1);
    }
};
const createRun = ({ shouldThrow }) => async function run(argv) {
    let migrationFunction;
    const terminate = makeTerminatingFunction({ shouldThrow });
    try {
        migrationFunction = require(argv.filePath);
    }
    catch (e) {
        const message = chalk_1.default `{red.bold The ${argv.filePath} script could not be parsed, as it seems to contain syntax errors.}\n`;
        console.error(message);
        terminate(new Error(message));
    }
    const application = argv.managementApplication || `contentful.migration-cli/${version}`;
    const feature = argv.managementFeature || `migration-library`;
    const clientConfig = Object.assign({
        application,
        feature
    }, config_1.getConfig(argv));
    const client = contentful_client_1.createManagementClient(clientConfig);
    const makeRequest = function (requestConfig) {
        const config = Object.assign({}, requestConfig, {
            url: [clientConfig.spaceId, 'environments', clientConfig.environmentId, requestConfig.url].join('/')
        });
        return client.rawRequest(config);
    };
    const migrationParser = migration_parser_1.default(makeRequest, clientConfig);
    let parseResult;
    try {
        parseResult = await migrationParser(migrationFunction);
    }
    catch (e) {
        if (e instanceof SpaceAccessError) {
            const message = [
                chalk_1.default `{red.bold ${e.message}}\n`,
                chalk_1.default `üö®  {bold.red Migration unsuccessful}`
            ].join('\n');
            console.error(message);
            terminate(new Error(message));
        }
        console.error(e);
        terminate(e);
    }
    if (parseResult.hasStepsValidationErrors()) {
        steps_errors_1.default(parseResult.stepsValidationErrors);
        terminate(new ManyError('Step Validation Errors', parseResult.stepsValidationErrors));
    }
    if (parseResult.hasPayloadValidationErrors()) {
        steps_errors_1.default(parseResult.payloadValidationErrors);
        terminate(new ManyError('Payload Validation Errors', parseResult.payloadValidationErrors));
    }
    const migrationName = path.basename(argv.filePath, '.js');
    const errorsFile = path.join(process.cwd(), `errors-${migrationName}-${Date.now()}.log`);
    const batches = parseResult.batches;
    if (parseResult.hasValidationErrors()) {
        render_migration_1.renderValidationErrors(batches, argv.environmentId);
        terminate(new ManyError('Validation Errors', parseResult.getValidationErrors()));
    }
    if (parseResult.hasRuntimeErrors()) {
        render_migration_1.renderRuntimeErrors(batches, errorsFile);
        await write_errors_to_log_1.default(parseResult.getRuntimeErrors(), errorsFile);
        terminate(new ManyError('Runtime Errors', parseResult.getRuntimeErrors()));
    }
    await render_migration_1.renderPlan(batches, argv.environmentId, argv.quiet);
    const serverErrorsWritten = [];
    const tasks = batches.map((batch) => {
        return {
            title: batch.intent.toPlanMessage().heading,
            task: () => new listr_1.default([
                {
                    title: 'Making requests',
                    task: async (_ctx, task) => {
                        // TODO: We wanted to make this an async interator
                        // So we should not inspect the length but have a property for that
                        const numRequests = batch.requests.length;
                        const requestErrors = [];
                        let requestsDone = 0;
                        for (const request of batch.requests) {
                            requestsDone += 1;
                            task.title = `Making requests (${requestsDone}/${numRequests})`;
                            task.output = `${request.method} ${request.url} at V${request.headers['X-Contentful-Version']}`;
                            await makeRequest(request).catch((error) => {
                                serverErrorsWritten.push(write_errors_to_log_1.default(error, errorsFile));
                                const parsed = JSON.parse(error.message);
                                const errorMessage = {
                                    status: parsed.statusText,
                                    message: parsed.message,
                                    details: parsed.details,
                                    url: parsed.request.url
                                };
                                requestErrors.push(new Error(JSON.stringify(errorMessage)));
                            });
                        }
                        // Finish batch and only then throw all errors in there
                        if (requestErrors.length) {
                            throw new BatchError(`Batch failed`, batch, requestErrors);
                        }
                    }
                }
            ])
        };
    });
    const confirm = async function (options) {
        if (options.skipConfirmation) {
            return { applyMigration: true };
        }
        return inquirer.prompt([{
                type: 'confirm',
                message: 'Do you want to apply the migration',
                name: 'applyMigration'
            }]);
    };
    const answers = await confirm({ skipConfirmation: argv.yes });
    if (answers.applyMigration) {
        try {
            const successfulMigration = await (new listr_1.default(tasks)).run();
            console.log(chalk_1.default `üéâ  {bold.green Migration successful}`);
            return successfulMigration;
        }
        catch (err) {
            console.error(chalk_1.default `üö®  {bold.red Migration unsuccessful}`);
            console.error(chalk_1.default `{red ${err.message}}\n`);
            err.errors.forEach((err) => console.error(chalk_1.default `{red ${err}}\n\n`));
            await Promise.all(serverErrorsWritten);
            console.error(`Please check the errors log for more details: ${errorsFile}`);
            terminate(err);
        }
    }
    else {
        console.warn(chalk_1.default `‚ö†Ô∏è  {bold.yellow Migration aborted}`);
    }
};
exports.runMigration = createRun({ shouldThrow: true });
exports.default = createRun({ shouldThrow: false });
//# sourceMappingURL=cli.js.map