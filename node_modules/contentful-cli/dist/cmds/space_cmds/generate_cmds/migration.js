'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handler = exports.generateFileName = exports.generateMigrationScript = exports.generateContentTypeMigration = exports.getContentTypes = exports.changeEditorInterface = exports.createField = exports.createContentType = exports.wrapMigrationWithBase = exports.ctVariableEscape = exports.ctNameNeedsEscaping = exports.aliases = exports.builder = exports.desc = exports.command = undefined;
exports.generateMigration = generateMigration;

var _async = require('../../../utils/async');

var _log = require('../../../utils/log');

var _recast = require('recast');

var _recast2 = _interopRequireDefault(_recast);

var _camelcase = require('camelcase');

var _camelcase2 = _interopRequireDefault(_camelcase);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _toAst = require('to-ast');

var _toAst2 = _interopRequireDefault(_toAst);

var _prettier = require('prettier');

var _prettier2 = _interopRequireDefault(_prettier);

var _contentfulClients = require('../../../utils/contentful-clients');

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const b = _recast2.default.types.builders;

const command = exports.command = 'migration';

const desc = exports.desc = 'Generate a migration file for your content model or a specific content type';

const builder = exports.builder = yargs => {
  return yargs.usage('Usage: contentful space generate migration').option('management-token', {
    describe: 'Content management API token',
    alias: 'mt',
    type: 'string'
  }).option('space-id', {
    describe: 'ID of the space the content model will belong to',
    alias: 's',
    type: 'string'
  }).option('environment-id', {
    describe: 'ID of the environment the content model will belong to',
    alias: 'e',
    type: 'string'
  }).option('content-type-id', {
    describe: 'ID of the content type to generate. If not provided, will generate the migration for the whole content model in the space',
    alias: 'c',
    type: 'string'
  }).option('filename', {
    describe: 'Output filename. If not provided will generate one with the format SPACE_ID-ENV_ID[-CT_ID]-TIMESTAMP',
    alias: 'f',
    type: 'string'
  }).epilog(['See more at:', 'https://github.com/contentful/contentful-cli/tree/master/docs/space/generate/migration', 'Copyright 2018 Contentful, this is a BETA release'].join('\n'));
};

const aliases = exports.aliases = ['m'];

const ctNameNeedsEscaping = exports.ctNameNeedsEscaping = function (ctId) {
  const reservedWords = ['break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'export', 'extends', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 'return', 'super', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield', 'enum', 'implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'await', 'abstract', 'boolean', 'byte', 'char', 'double', 'final', 'float', 'goto', 'int', 'long', 'native', 'short', 'synchronized', 'throws', 'transient', 'volatile'];

  if (reservedWords.indexOf(ctId) !== -1) {
    return true;
  }
  if (!isNaN(ctId.charAt(0))) {
    return true;
  }

  return false;
};

const ctVariableEscape = exports.ctVariableEscape = function (ctId) {
  const camelCased = (0, _camelcase2.default)(ctId);
  return ctNameNeedsEscaping(camelCased) ? `_${camelCased}` : camelCased;
};

const wrapMigrationWithBase = exports.wrapMigrationWithBase = function (blockStatement) {
  const migration = b.program([b.expressionStatement(b.assignmentExpression('=', b.memberExpression(b.identifier('module'), b.identifier('exports')), b.functionExpression(null, [b.identifier('migration')], blockStatement)))]);

  return migration;
};

const createCallChain = function (base, chain) {
  if (chain.length === 0) {
    return base;
  }

  const [identifier, value] = chain[0];
  const rest = chain.slice(1);

  return createCallChain(b.callExpression(b.memberExpression(base, b.identifier(identifier)), [(0, _toAst2.default)(value)]), rest);
};

const createContentType = exports.createContentType = function (ct) {
  const id = ct.sys.id;
  const { name, description, displayField } = ct;
  const chain = [['name', name], ['description', description], ['displayField', displayField]].filter(([id, value]) => value !== null);

  const variableName = ctVariableEscape(id);

  const createCallExpression = b.callExpression(b.memberExpression(b.identifier('migration'), b.identifier('createContentType')), [b.literal(id)]);

  const callChain = createCallChain(createCallExpression, chain);

  const withDeclaration = b.variableDeclaration('const', [b.variableDeclarator(b.identifier(variableName), callChain)]);

  return withDeclaration;
};

const createField = exports.createField = function (ctId, field) {
  const fieldId = field.id;
  const ctVariable = ctVariableEscape(ctId);

  const chain = Object.keys(_lodash2.default.omit(field, 'id')).map(key => {
    return [key, field[key]];
  });

  return createCallChain(b.callExpression(b.memberExpression(b.identifier(ctVariable), b.identifier('createField')), [b.literal(fieldId)]), chain);
};

const changeEditorInterface = exports.changeEditorInterface = function (ctId, fieldId, widgetId, settings) {
  const ctVariable = ctVariableEscape(ctId);
  settings = settings || {};

  const settingsExpression = b.objectExpression(_lodash2.default.map(settings, (v, k) => {
    return b.property('init', b.identifier(k), b.literal(v));
  }));

  return b.callExpression(b.memberExpression(b.identifier(ctVariable), b.identifier('changeEditorInterface')), [b.literal(fieldId), b.literal(widgetId), settingsExpression]);
};

const getContentTypes = exports.getContentTypes = async function (environment, contentTypeId) {
  return contentTypeId ? [await environment.getContentType(contentTypeId)] : (await environment.getContentTypes()).items;
};

const generateContentTypeMigration = exports.generateContentTypeMigration = async function (environment, contentType) {
  (0, _log.log)(`Creating migration for content type: '${contentType.sys.id}'`);

  const fieldCreators = contentType.fields.map(field => {
    return b.expressionStatement(createField(contentType.sys.id, field));
  });

  let editorInterfacesCreators = [];
  try {
    (0, _log.log)('Fetching editor interface');

    const editorInterface = await environment.getEditorInterfaceForContentType(contentType.sys.id);
    editorInterfacesCreators = contentType.fields.map(field => {
      const control = _lodash2.default.find(editorInterface.controls, control => {
        return control.fieldId === field.id;
      });
      const widgetId = control.widgetId;
      const settings = control.settings;

      return b.expressionStatement(changeEditorInterface(contentType.sys.id, field.id, widgetId, settings));
    });
  } catch (err) {
    if (err.name === 'NotFound') {
      (0, _log.log)('Skipping editor interfaces. Content type has no fields.');
    } else {
      (0, _log.warning)(err);
    }
  }

  return [createContentType(contentType)].concat(fieldCreators).concat(editorInterfacesCreators);
};

const generateMigrationScript = exports.generateMigrationScript = async function (environment, contentTypes) {
  const migrationContents = await Promise.all(_lodash2.default.map(contentTypes, async contentType => {
    return generateContentTypeMigration(environment, contentType);
  }));
  const migration = wrapMigrationWithBase(b.blockStatement(_lodash2.default.flatten(migrationContents)));

  const output = _recast2.default.prettyPrint(migration, { tabWidth: 2 }).code;
  return _prettier2.default.format(output);
};

const generateFileName = exports.generateFileName = function (spaceId, environmentId, contentTypeId) {
  const contentTypePart = contentTypeId ? `-${contentTypeId}` : '';

  return `${spaceId}-${environmentId}${contentTypePart}-${Date.now()}.js`;
};

const createManagementClient = function (managementToken) {
  return (0, _contentfulClients.createManagementClient)({
    accessToken: managementToken,
    feature: 'migration-generate'
  });
};

const getEnvironment = async function (managementToken, spaceId, environmentId) {
  const client = await createManagementClient(managementToken);
  const space = await client.getSpace(spaceId);
  return space.getEnvironment(environmentId);
};

async function generateMigration({ context, filename: filenameFlag, contentTypeId }) {
  const { managementToken, activeSpaceId, activeEnvironmentId } = context;

  const filename = filenameFlag || generateFileName(activeSpaceId, activeEnvironmentId, contentTypeId);

  const environment = await getEnvironment(managementToken, activeSpaceId, activeEnvironmentId);

  (0, _log.log)('Fetching content model');
  const contentTypes = await getContentTypes(environment, contentTypeId);

  _fs2.default.writeFileSync(filename, (await generateMigrationScript(environment, contentTypes)));
  (0, _log.success)(`Migration file created at ${filename}`);
}

const handler = exports.handler = (0, _async.handleAsyncError)(generateMigration);