'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logEmitter = undefined;
exports.formatLogMessageOneLine = formatLogMessageOneLine;
exports.formatLogMessageLogfile = formatLogMessageLogfile;
exports.displayErrorLog = displayErrorLog;
exports.writeErrorLogFile = writeErrorLogFile;
exports.setupLogging = setupLogging;
exports.logToTaskOutput = logToTaskOutput;

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _bfj = require('bfj');

var _bfj2 = _interopRequireDefault(_bfj);

var _lodash = require('lodash');

var _figures = require('figures');

var _figures2 = _interopRequireDefault(_figures);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _getEntityName = require('./get-entity-name');

var _getEntityName2 = _interopRequireDefault(_getEntityName);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var logEmitter = exports.logEmitter = new _events2.default();

function extractErrorInformation(error) {
  var source = error.originalError || error;
  try {
    var data = JSON.parse(source.message);
    if ((0, _lodash.isObject)(data)) {
      return data;
    }
  } catch (err) {
    throw new Error('Unable to extract API error data');
  }
}

function formatLogMessageOneLine(logMessage) {
  var level = logMessage.level;

  if (!level) {
    return logMessage.toString().replace(/\s+/g, ' ');
  }
  if (level === 'info') {
    return logMessage.info;
  }
  if (level === 'warning') {
    return logMessage.warning;
  }
  try {
    // Display enhanced API error message when available
    var errorOutput = [];
    var data = extractErrorInformation(logMessage.error);
    if ('status' in data || 'statusText' in data) {
      var status = [data.status, data.statusText].filter(function (a) {
        return a;
      }).join(' - ');
      errorOutput.push(`Status: ${status}`);
    }
    if ('message' in data) {
      errorOutput.push(`Message: ${data.message}`);
    }
    if ('entity' in data) {
      errorOutput.push(`Entity: ${(0, _getEntityName2.default)(data.entity)}`);
    }
    if ('details' in data && 'errors' in data.details) {
      var errorList = data.details.errors.map(function (error) {
        return error.details || error.name;
      });
      errorOutput.push(`Details: ${errorList.join(', ')}`);
    }
    if ('requestId' in data) {
      errorOutput.push(`Request ID: ${data.requestId}`);
    }
    return `${logMessage.error.name}: ${errorOutput.join(' - ')}`;
  } catch (err) {
    // Fallback for errors without API information
    return logMessage.error.toString().replace(/\s+/g, ' ');
  }
}

function formatLogMessageLogfile(logMessage) {
  var level = logMessage.level;

  if (level === 'info' || level === 'warning') {
    return logMessage;
  }
  if (!logMessage.error) {
    // Enhance node errors to logMessage format
    logMessage.error = logMessage;
  }
  try {
    // Enhance error with extracted API error log
    var data = extractErrorInformation(logMessage.error);
    var errorOutput = Object.assign({}, logMessage.error, { data });
    delete errorOutput.message;
    logMessage.error = errorOutput;
  } catch (err) {
    // Fallback for errors without API information
    if (logMessage.error.stack) {
      logMessage.error.stacktrace = logMessage.error.stack.toString().split(/\n +at /);
    }
  }

  // Listr attaches the whole context to error messages.
  // Remove it to avoid error log file pollution.
  if (typeof logMessage.error === 'object' && 'context' in logMessage.error) {
    delete logMessage.error.context;
  }

  return logMessage;
}

// Display all errors
function displayErrorLog(errorLog) {
  if (errorLog.length) {
    var warningsCount = errorLog.filter(function (error) {
      return error.hasOwnProperty('warning');
    }).length;
    var errorsCount = errorLog.filter(function (error) {
      return error.hasOwnProperty('error');
    }).length;
    console.log(`\n\nThe following ${errorsCount} errors and ${warningsCount} warnings occurred:\n`);

    errorLog.map(function (logMessage) {
      return `${(0, _moment2.default)(logMessage.ts).format('HH:mm:SS')} - ${formatLogMessageOneLine(logMessage)}`;
    }).map(function (logMessage) {
      return console.log(logMessage);
    });

    return;
  }
  console.log('No errors or warnings occurred');
}

// Write all log messages instead of infos to the error log file
function writeErrorLogFile(destination, errorLog) {
  var logFileData = errorLog.map(formatLogMessageLogfile);

  return _bfj2.default.write(destination, logFileData, {
    circular: 'ignore',
    space: 2
  }).then(function () {
    console.log('\nStored the detailed error log file at:');
    console.log(destination);
  }).catch(function (e) {
    // avoid crashing when writing the log file fails
    console.error(e);
  });
}

// Init listeners for log messages, transform them into proper format and logs/displays them
function setupLogging(log) {
  function errorLogger(level, error) {
    var logMessage = {
      ts: new Date().toJSON(),
      level,
      [level]: error
    };
    if (level !== 'info') {
      log.push(logMessage);
    }
    logEmitter.emit('display', logMessage);
  }

  logEmitter.addListener('info', function (error) {
    return errorLogger('info', error);
  });
  logEmitter.addListener('warning', function (error) {
    return errorLogger('warning', error);
  });
  logEmitter.addListener('error', function (error) {
    return errorLogger('error', error);
  });
}

// Format log message to display them as task status
function logToTaskOutput(task) {
  function logToTask(logMessage) {
    var content = formatLogMessageOneLine(logMessage);
    var symbols = {
      'info': _figures2.default.tick,
      'warning': _figures2.default.warning,
      'error': _figures2.default.cross
    };
    task.output = `${symbols[logMessage.level]} ${content}`.trim();
  }

  var startTime = Date.now();

  logEmitter.on('display', logToTask);

  return function () {
    var seconds = Math.ceil((Date.now() - startTime) / 1000);
    task.title = `${task.title} (${seconds}s)`;
    logEmitter.removeListener('display', logToTask);
  };
}